<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Central content type catalog for Eclipse</title>
  <link rel="stylesheet" href="default_style.css" type="text/css">
</head>
<body text="#000000" bgcolor="#ffffff">
<h1>A central content type catalog for Eclipse</h1>
<p><font size="-1">Last modified: March 17, 2004</font> </p>
<p><cite><strong>Plan item description:</strong> Content-type-based editor lookup. 
  The choice of editor is currently based on file name pattern. This is not very 
  flexible, and breaks down when fundamentally different types of content are 
  found in files with undistinguished file names or internal formats. For example, 
  many different models with specialized editors get stored in XML format files 
  named *.xml. Eclipse should support a notion of content type for files and resources, 
  and use these to drive decisions like which editor to use. This feature would 
  also be used by team providers when doing comparisons based on file type. The 
  several existing file-type registries in Eclipse should be consolidated. [Platform 
  Core, Platform UI] [Theme: User experience] (bug <a
 href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=37668">37668</a>, <a
 href="http://dev.eclipse.org/bugs/show_bug.cgi?id=51791">51791</a>, <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=52784">52784</a>) 
  </cite></p>
<p>This plan item is about two important features: </p>
<ol>
  <li>a single content-type repository to be provided by Eclipse on top of which
  content-type related features provided by any plugins could be built upon, and</li>
  <li>a mechanism for automatically determining the content type given a file name and/or its 
  contents.</li>
</ol>
<h2>Driving forces</h2>
<ul>
  <li>the catalog must be extensible: plug-ins must be able to contribute new 
    content types;</li>
  <li>content types must have an identity, a unique identifier by which they can 
    be unambiguously retrieved from the catalog;</li>
  <li>content types should be hierarchical: new content types are very often specializations 
    of existing ones (example, Ant Scripts and Plugin manifests are kinds of XML 
    documents, XML is a kind of text document), so it should be possible for new 
    content types to inherit interesting properties from existing ones (see <a href="#FAQ-hierarchy">FAQ</a>);</li>
  <li>content types have either a predominantly binary or text nature;</li>
  <li>content types are associated with specific file names/extensions;</li>
  <li>content types may optionally correspond to MIME types (see <a href="#FAQ-MIME">FAQ</a>);</li>
  <li>some level of automatic content/name based type discovery must be provided;</li>
  <li>existing plug-in-specific content type catalogs should be replaced/built 
    upon the central catalog;</li>
  <li>encoding determination is strongly related concern and should taken into 
    consideration when sketching a solution.</li>
</ul>
<h2>Solution</h2>
<h3>The proposed API</h3>
<p>The proposed API contains 4 new interfaces in a new package called <code>org.eclipse.core.runtime.content</code>:</p>
<ul>
  <li><code><a href="#IContentType">org.eclipse.core.runtime.content.IContentType</a></code></li>
  <li><code><a href="#IContentTypeManager">org.eclipse.core.runtime.content.IContentTypeManager</a></code></li>
  <li><code><a href="#IContentDescription">org.eclipse.core.runtime.content.IContentDescription</a></code></li>
  <li><code><a href="#IContentDescriber">org.eclipse.core.runtime.content.IContentDescriber</a></code></li>
</ul>
<p>Following is a brief description for each of them. </p>
<h4><code><a name="IContentType"></a>org.eclipse.core.runtime.content.IContentType</code></h4>
<p>Represents a content type in the platform. <code>IContentType</code> instances 
  are provided by the platform, built from extensions to the <code>org.eclipse.core.runtime.contentTypes</code> 
  extension point. Relevant properties for <code>IContentType</code> are:</p>
<ul>
  <li>unique id (example: org.eclipse.core.runtime.xml);</li>
  <li>user-friendly name (example: Plain Text);</li>
  <li>file selection spec - currently, comma-separated lists of associated file 
    names and extensions (example: htm,html);</li>
  <li>default charset (example: UTF-8);</li>
  <li>content describer (see <code><a href="#IContentDescriber">org.eclipse.core.runtime.content.IContentDescriber</a></code>);</li>
  <li>mime type (see <a href="#FAQ-MIME">FAQ</a>);</li>
  <li>the type this type descends from, if any (see <a href="#FAQ-hierarchy">FAQ</a>);</li>
  <li>text/binary nature (boolean). Only org.eclipse.core.runtime.text and its 
    sub types are considered text types.</li>
</ul>
<p>Also, <code>IContentType</code> provides a method that checks whether the given 
  file name is matched by this content type file selection spec.</p>
<h4><a name="IContentTypeManager"></a><code>org.eclipse.core.runtime.content.IContentTypeManager</code></h4>
<p>Represents the content type catalog. Provides methods for obtaining the content 
  type associated to a file name, and for discovering the corresponding content 
  type for a stream of bytes. <code>IContentTypeManager</code> allows clients 
  to:</p>
<ul>
  <li>retrieve the content type for a given id;</li>
  <li>retrieve a set of content types associated to a given file name;</li>
  <li>select, from a given set, which content types recognize a given stream as 
    a valid sample for the corresponding file format;</li>
  <li>obtain a description for a stream of bytes, including platform and custom 
    (content type specific) properties.</li>
</ul>
<h4><code><a name="IContentDescriber"></a>org.eclipse.core.runtime.content.IContentDescriber</code></h4>
<p>Content-based content type detection and content description rely on specialized 
  content detectors associated to content types. When a content type is contributed 
  to the platform, a content describer class may be provided. Content describers 
  are able to detect if a given stream of bytes is conformant to the content type 
  file format, and may also be able to extract important properties from the contents, 
  such as what charset was used to encode the contents (for text files), and any 
  content type specific information that may be required.</p>
<p>The main method in <code>IContentDescriber</code> is:</p>
<p><code>int describe(InputStream contents, IContentDescription description, int 
  optionsMask) throws IOException;</code></p>
<p>The first thing implementations for this method must do is to check if the 
  contents represent a valid sample for their corresponding content type file 
  format. If not, this method should exit immediately, returning <code>IContentDescription.INVALID</code> 
  or <code>IContentDescription.UNKNOWN</code>, depending on how strict the file 
  format is. Otherwise, this method should return <code>IContentDescription.VALID</code>, 
  but only after trying to provide all required information (according to the 
  specified options, if any) by reading the contents and filling the <a href="#IContentDescription">content 
  description</a> provided. </p>
<p><strong><em>Note</em></strong><em>: it is essential that for this mechanism 
  to work in a suitable manner, the execution of content describers by the platform 
  should not cause the activation of the plugins providing them. In the Eclipse 
  3.0 runtime, plug-ins that have built-in bundle manifests will be able to selectively 
  enable/disable auto-activation on a per-package basis (for more information, 
  see <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=52393">bug 52393</a>). 
  Content describers <strong>must</strong> be defined in packages that are excluded 
  from auto-activation, otherwise the platform may refuse to accept them.</em></p>
<h4><code><a name="IContentDescription"></a>org.eclipse.core.runtime.content.IContentDescription</code></h4>
<p>Content descriptions are obtained by calling IContentTypemanager#getDescriptionFor 
  method. A content description contains interesting information (such as encoding) 
  about an arbitrary stream of bytes. These information are filled partially by 
  the platform and partially by the content describer ellected (if any).</p>
<h3>Automatic content type detection</h3>
<p>Content types determine many properties and actions related to files such as 
  encodings, associated editors, etc. Automatic content type determination allows 
  content type specific actions without requiring the user to manually define 
  the content type for a given file. Content type detection is based on:</p>
<ul>
  <li>file name/extension</li>
  <li>file contents</li>
  <li>user preference</li>
</ul>
<p>Content type determination based on file name/extension (&quot;file selection 
  specs&quot;) is the easiest to implement. Each content type has a set of file 
  selection specs associated to it. Determining the content type corresponding 
  to a file selection spec is done by a simple lookup on the catalog. If multiple 
  content types may be associated with a same filespec, it may be useful to be 
  able to determine a ranking between those content types.</p>
<p>Content type determination based on file contents is more complex, and requires 
  the examination of the contents. Since we are talking about an open set of possible 
  content types, this examination implies in delegation to content type detectors 
  contributed by other plug-ins.</p>
<h3>Frequently Asked Questions</h3>
<ol>
  <li> How will plugin providers benefit from a central content type catalog? 
    <p> Generally by using the same content type registry and sharing the same 
      concept of content/file type. Other examples are: 
    <ul>
      <li>CVS could know whether a new resource should be marked as binary or 
        text;</li>
      <li>a builder could use its well-known content type to filter out files 
        whose names don't match with the content type file section spec;</li>
      <li>the user interface could know what editors to offer for a given file 
        selected (associations between editors and content types should be kept 
        separately from the content type catalog);</li>
    </ul></p>
    </li>
  <li><a name="FAQ-hierarchy"></a>Why are content types hierarchical? 
    <p>To allow important properties to be inherited by new, specialized content 
      types: 
    <ul>
      <li>the default charset</li>
      <li>text/binary nature</li>
      <li>content description</li>
      <li>associations defined externally by plug-ins (for instanec, any editors 
        associated with an ancestor should work with any descendants)</li>
    </ul></p>
    </li>
  <li> In the case of multiple content types associated to a given file, how are 
    they ranked? 
    <p> The user may define which content type is the default for a given file 
      spec. If the user has not made any choice, we need to determine it automatically. 
      The ranking system as proposed in <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=52784">bug 
      52784</a> would be a good approach.</p>
  </li>
  <li>What happens if the base type for a new content type is not present in the 
    platform (the plug-in that provides it is not available)? 
    <p>The content type will be deemed invalid and ignored.</p>
  </li>
  <li><a name="FAQ-MIME"></a>What are MIME types used for? Is there 
    any special relationship between two different content types that share the 
    same MIME type? 
    <p>TBD</p>
  </li>
</ol>
</body></html>
