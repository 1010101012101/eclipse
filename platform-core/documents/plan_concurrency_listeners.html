<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Resource change listeners in a concurrent world</title>
  <link rel="stylesheet" href="http://dev.eclipse.org/default_style.css" type="text/css">
</head>
<body text="#000000" bgcolor="#FFFFFF">
 
<h1>Listeners and builders in a concurrent world</h1>
<font size="-1">[Draft copy] </font><br><br>
<font size="-1">Last modified: July 23, 2003</font> 

<p>In the context of the work on improving platform responsiveness,
there will be some important changes to how resource change listeners
and incremental project builders operate.  This document describes and 
motivates these proposed changes.
The existing (Eclipse 2.1) behavior of listeners will be described in detail, 
along with a description of how this will change in Eclipse 3.0.
Finally, a draft of the porting guide is included, describing how
existing implementations might be impacted and 
how they can adapt to the new behavior.
<h3>Overview and motivation</h3>
<p>
The principal proposed change for release 3.0 is that resource change listeners 
and auto-build will be called in a separate thread from which the workspace change 
occurred.  This means listeners and builders will run concurrently with the thread that 
caused the change, and there will 
be <b>no guarantee at all</b> about precisely when listeners and builders will 
be called.  The only guarantee is that all resource change listeners will 
<b>eventually</b> be notified of all workspace changes, and that all builders
will eventually be run when auto-build is turned on.</p>
<p>
There are a number of motivations for this change.  First, there is a need to minimize 
the duration for which the workspace lock is held by an operation.  In Eclipse 2.1, 
every workspace operation had an automatic resource change notification and 
auto-build cycle attached to the end of it.  The operation did not complete until
all notifications and auto-builds had finished.  For the entire duration of this cycle, 
the workspace was locked to prevent concurrent changes in other threads.  
This long term exclusive locking must be reduced if there is any hope to obtain 
greater concurrency in Eclipse 3.0.  One way to shorten the duration of this locking
is to split up the operation itself, the resource change notifications, and the auto-build
into separate units of work.
</p>
<p>
In addition, this rigid
notification and build strategy resulted in poor performance if clients
neglected to batch groups of changes into a single operation (via 
<code>IWorkspaceRunnable</code>).  Decoupling the workspace operation
from the build/notification phase allows us to employ strategies to limit the number
of resource change notifications, and to lower the priority of notifications and builds
to give precedence to other workspace changing operations.
</p>
<p>
Moreover, since resource change notifications strongly impacted the
duration of all workspace modifying operations, there were severe limits to 
what resource change listeners could do.  Listener implementors had to consider
performance as a primary design goal, and were not allowed to make modifications
to the workspace.  With listeners running in a separate thread, performance
is not as sensitive, and listeners can be allowed to run longer and make changes to 
the workspace.
</p>
<p>
Another change that will be made to improve responsiveness is to add notifications
<b>during</b> long running operations.  An upper bound will be introduced on the
delay between a workspace change and the notification.  This means that even if an 
operation takes several minutes, it will be reporting incremental resource changes 
periodically throughout the operation.  The increased notifications will act as an added
feedback mechanism to show the user that progress is being made on an operation.
This also allows the user to begin working with some of the output
of the operation before it completes.  For example, a user will be able to begin 
editing imported files before the import is complete, if the import is taking a long time.
</p>

<h3>Old behavior of resource change listeners</h3>
<p>The following list gives an overview of the API contract rules that are currently specified
in Eclipse release 2.1.  The goal for any new listener implementation is to avoid breaking
these rules in any significant way.
</p>
<ol>
<li>Listeners are guaranteed to receive only the event types for which they are 
registered.</li>
<li>Listeners begin receiving resource change notifications after they are added to
the workspace, and they continue to receive notifications until they are explicitly
removed.</li>
<li>All listeners receive an identical resource change event with an identical
resource delta for each event cycle.</li>
<li>Listeners are not allowed to modify the workspace during <code>POST_CHANGE</code>,
<code>PRE_CLOSE</code>, or <code>PRE_DELETE</code> event notifications.</li>
<li>For events that allow resource changes during notification, any resource
changes must be made in the thread in which the notification occurs.</li>
<li>Resource change notifications are batched until the outermost <code>IWorkspaceRunnable
</code> in a given thread is finished, or until <code>IWorkspace.checkpoint</code> is called.</li>
</ol>

<p>In addition to these API rules, resource change listeners in Eclipse 2.1 have some
other important characteristics.  Although these are not spelled out in
the API, some listener implementations may be making assumptions based on
this observed behavior, and could be affected if they change.

<ol>
<li>The operation that caused the resource change will not return until all listeners
have been notified.</li>
<li>Listeners are called in the same thread in which the operation that made the 
change occurred.  From one change to the next, this thread can vary.</li>
<li>The delta received by a listener precisely describes the differences between the
current state of the workspace and the state of the workspace when the listener
was last invoked.  For example, if the delta says a resource was added, then it
is absolutely certain that the resource exists at the time when the listener is
called, and that it did not exist at the time when the listener was last called.</li>
<li>Listeners are never called concurrently with any workspace changing operation.</li>
<li>Once registered, a resource change listener will receive notification of <b>all</b>
resource changes that occur in the workspace until it is removed, or until the
resources plug-in shuts down. (Note: although this is not spelled out in the API, this
is a fundamentally important characteristic that should never change.  Without this,
listeners would not be able to reliably maintain a consistent domain model on top
of the workspace using listeners.)</li>
<li>If a listener is added in the middle of an operation,
it will receive notification of all changes that occurred since the start of that operation.
If a listener is removed in the middle of an operation, it will not receive notification of
any changes that occurred during that operation.</li>
<li>Listeners are called sequentially in a consistent order.  There is no way for clients
to influence or discover the ordering of listeners.</li>
<li>All listeners for a given event are called in the same thread.</li>
</ol>
<h3>Overview of changes for listeners in Eclipse 3.0</h3>
<p>
Under the proposed changes, the first four characteristics in the list above will
no longer be true.  Workspace operations may now return before or during
the resource change notification.  The change notifications will occur in a different
thread from the one in which the operation ran.  One notable instance is that 
when the workspace is changed from within the UI thread, it will NOT follow that 
the resource change notification also occurs in the UI thread.
</p>
<p>
Running listeners in the background allows us to lift the restriction that resource
change listeners not be allowed to modify the workspace (API contract rule #4 above).  
Many clients wish to make minor changes to the workspace during notification, such as adding or
removing markers.  This restriction will now be lifted since slow listeners will 
no longer affect the duration of workspace operations.  All listeners will receive 
notification about changes made by listeners, although this secondary 
notification won't happen immediately after the notification that caused the change.  
Listeners will also receive notification about changes they made themselves, 
allowing us to maintain the invariant that listeners are notified of absolutely all 
changes to the workspace.
</p>
<p>
Since listeners will be allowed to make changes, and since our API specifies that
all listeners receive exactly the same event and delta, characteristic #3 listed
above can no longer hold.  When the delta is received, it will not necesarily 
be true that the delta will describe the exact state of the world at that instant.  Further 
changes may have been made that are not included in the current delta, but will be 
included in a future delta.  In fact, resource changes may still be happening 
in another thread at the time when the notification is received.  
</p>
<h3>Overview of changes for builders in Eclipse 3.0</h3>
<p>
The proposed changes for incremental project builders are much more conservative.
The task of an incremental builder is to reconcile an arbitrary set of changes
to a densely interconnected web of source files to produce an output that 
is a consistent representation of the source.  This is a difficult enough task to achieve 
in a single-threaded environment that to attempt it in a concurrent environment 
would be courting disaster.  On the other hand, building can take a long time, and
there is a very high value in moving this work to a non-blocking background thread
to allow the user to continue working.
</p>
<p>
With these factors in mind, the proposal is to move auto-build into a background
thread, but to preempt the build when another operation attempts to modify the
workspace.  A typical work flow would go like this:
<ol>
<li>A user modifies a file and saves the change.</li>
<li>Auto-build starts.</li>
<li>The user modifies the file again and attempts to save.</li>
<li>The auto-build started in step 2 is halted at the nearest convenient stopping point.</li>
<li>The file modification is allowed to proceed.</li>
<li>Auto-build starts running again.</li>
</ol>
The &quot;nearest convenient stopping point&quot; in this case is at the end
of the current builder invocation.  No builder will be halted in the middle of building
a single project.  This strategy ensures that the user doesn't have to wait long before they
are allowed to make their change, and that workspace changes don't happen in the
middle of a single builder invocation.  When a preempted auto-build resumes, it must
start again at the beginning of the build order to ensure that interdependent projects
are built in the correct order.  However, builders that successfully ran
before will not be given the same delta again.
</p>
<p>
This new strategy is designed to have no impact on existing builder implementations.
In essence, this approach is equivalent to a mode where auto-build is off, but a
background thread is performing an incremental build periodically.  In other words, since this
strategy (apart from the preemption) can be implemented using existing API, it 
should have no impact on existing builders.  No new API is proposed for builders,
and no API changes are planned.
</p>

<h3>Summary of proposed API changes</h3>
<p>
The proposed changes described in this document require two changes
to the current API contract of resource change listeners:
<ol>
<li>The restriction that resource changes not be allowed during certain resource change
events will be removed.  Resource changes will be allowed during all resource change
events.  Since this amounts to removing an API restriction, this is not a breaking change.</li>
<li>It will no longer be guaranteed that all resource changes that occur during the
dynamic scope of an <code>IWorkspaceRunnable</code> will be batched in a single
notification.  This mechanism can still be used for batching changes to avoid unneccessary
builds and notifications, but the platform may decide to perform a notification during the
operation if sufficient time has elapsed.  Note that it was previously possible for resource
change notifications to occur during the invocation of an <code>IWorkspaceRunnable</code>
via the <code>IWorkspace.checkpoint</code> API method.  Therefore, this API change
is not likely to be a breaking change for existing clients.  It is equivalent to the platform
deciding to call <code>IWorkspace.checkpoint</code> periodically during a long running
operations.</li>
</ol>
</p>
<p>
In addition to these API changes, there will be a number of changes to some of
the unspecified characteristics of resource change listeners.  Below is a summary
of new characteristics of resource change listeners for Eclipse 3.0.
<ol>
<li>The operation that caused the resource change may return before any listeners
have been notified.</li>
<li>Listeners may be called in a different thread from the operation that made the 
change.</li>
<li>The delta received by a listener may not precisely describe the differences 
between the current state of the workspace and the state of the workspace when 
the listener was last invoked.  It will simply be true that the delta will accurately
describe changes that occurred at some point in the recent past.  If the delta says
that a resource was added, it may have been deleted again by the time the listener
receives the notification.</li>
</ol>
</p>
<h3>How clients might be impacted</h3>
<p>
Client code that makes assumptions about when resource change listeners run are
likely to be broken by this change.  The following are some sample situations:
<h4>Views not reflecting workspace model</h4>
<p>
UI components that display resources typically keep their view up to date by registering
a resource change listener that reconciles workspace changes with the view contents.
<tt>org.eclipse.ui.model.WorkbenchContentProvider</tt> is the most common 
example of this idiom.  With listeners running asynchronously, there will be a period
after a workspace change when the listeners have not yet been called.  During this 
period, views will be out of date with the model.  For example, the following code 
pattern (often found in wizards) will now be prone to failure:
<ul>
<li>create resource</li>
<li>select and reveal resource in navigator</li>
</ul>
This will fail if the select and reveal code is run before the resource change
notification is finished.  It will attempt to select a resource that is not yet 
in the view.
</p>
<h4>Domain model out of sync with workspace</h4>
<p>
Similar to the above situation, client components often maintain the
structure of a domain-specific model using resource change listeners.

<h3>What to do about it</h3>
<p>
TBD
</p>
<h3>Status and schedule</h3>
<p>
Background resource change listeners and auto-build have been implemented
and some basic testing has been done.  All work is currently in branch "Bug_36957" 
of project org.eclipse.core.resources. Basic sanity checking of the SDK reveals no 
significant problems, and some core team members are self-hosting with it.  
All platform core test suites now pass with background 
notification and build.  These changes will be rolled into integration builds over the 
next two weeks:
<ul>
<li>Tuesday, July 29: release to HEAD stream for nightly build.</li>
<li>Tuesday, August 5: release for 3.0 stream integration build.</li>
</ul>
<p>
Go <a href="../plan_concurrency.html">back to concurrency home</a>.
</p>
(Plan item bug reference: <a
 href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=36957">36957</a>)<br>
</body>
</html>