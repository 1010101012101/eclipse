<html>
<head>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<title>Eclipse 3.0 Runtime Porting Guide</title>
		<link rel="stylesheet" title="default" href="http://eclipse.org/default_style.css" type="text/css">
		<style>
			th,td { vertical-align:top; text-align=left}
			.issue { font-style:oblique; width:200px;}
			.box	{ background-color:#E0E0FF}
		</style>
	</head>
	<body>
		<table BORDER=0 CELLSPACING=5 CELLPADDING=2 WIDTH="100%" >
			<tr> 
				<td ALIGN=left width="60%">
					
      <p><font class=indextop> eclipse</font><br>
        <font class=indexsub> eclipse 3.0 runtime porting guide</font> </p>
				</td>
				<td WIDTH="40%">&nbsp; </td>
			</tr>
		</table>

<blockquote> 
  <p><b>Summary</b> <br>
    This document details how to move from running the runtime in Eclipse 2.x 
    to using the new runtime included in Eclipse 3.0. Included here is information 
    on required and recommended changes to Eclipse 2.x plug-in writers to make 
    them run in the Eclipse 3.0 environment. Information on how to use the new 
    runtime is contained in the <a href="howto.html">Users Guide</a>.<br>
    Last Modified: 2300 November 29, 2003</p>
  
</blockquote>

<table border=0 cellspacing=0 cellpadding=2 width="100%" >
  <tr> 
    <td align=LEFT valign=TOP colspan="2" bgcolor="#0080C0"><b><font color="#FFFFFF"> 
      Required changes</font></b></td>
  </tr>
</table>
<p> Below is a list of the changes which must be carried out on Eclipse 2.x plug-ins 
  to allow them to function correctly in an Eclipse 3.0 environment. The Eclipse 
  3.0 runtime includes a compatibility layer which is 99% binary compatible with 
  Eclipse 2.1. As such, very few plug-ins should actually require updating. The 
  information below details who is affected by the changes as well as what action 
  needs to be taken. </p>
<h3>URL Stream Handler extensions</h3>
<p><b>Who is affected:</b> Plug-ins which contribute extensions to the <tt>org.eclipse.core.runtime.urlHandlers</tt> 
  extension point. While useful, it appears that very few plug-ins have a need 
  for this facility. Eclipse itself uses it and a quick scan of major Eclipse-based 
  products (e.g., WSAD) uncovered one or two more.</p>
<p><b>Description:</b> OSGi provides a URL Stream Handler service much like that 
  supported by Eclipse runtime which allows for the registration of URL stream 
  handlers for different URL protocols (e.g., jndi: URLs). The OSGi support is 
  superior to that in Eclipse 2.1 in that it correctly handles dynamic handlers 
  (i.e., ones which come and go). Because of various design issues with the base 
  Java URL handler mechanism, URLStreamHandlers registered with the OSGi handler 
  service must implement <tt>org.osgi.service.url.URLStreamHandlerService</tt>. 
  The OSGi framework provides a handy abstract superclass (<tt>org.osgi.service.url.AbstractURLStreamHandlerService</tt>) 
  that does the bulk of this work. </p>
<p><b>Action required:</b> Unfortunately, legacy plug-ins which supply URL handler 
  contributions (extensions to the <tt>org.eclipse.core.runtime.urlHandlers</tt> 
  extension point) implement only the <tt>java.net.URLStreamHandler</tt> contract. 
  Since all of the methods on URLStreamHandler are protected, it is not possible 
  for the runtime compatibility layer to simply wrap such handlers to and give 
  them the required behaviour. Rather, the implementation of your handler must 
  be updated either to implement <tt>org.osgi.service.url.URLStreamHandlerService</tt> 
  or to extend <tt>org.osgi.service.url.AbstractURLStreamHandlerService</tt>.</p>
<h3>Classload order</h3>
<p><b>Who is affected:</b> Plug-ins which supply packages provided which are also 
  supplied by other plug-ins. A very limited number of plug-ins are affected by 
  this change and some of those affected will actually benefit (see below).</p>
<p><b>Description:</b> In Eclipse 2.x, classloaders search for classes using the 
  so-called <i>PSP</i> ordering. That is, a given classloader would first consult 
  its <b>p</b>arent classloader (in practice this is the Java boot classloader), 
  then its own classpath contents (i.e., <b>s</b>elf) and finally all of its <b>p</b>rerequisites 
  in declared order. OSGi offers an optimization over this model, the so-called 
  <i>PP|S</i> (read P, P or S) ordering. In this approach a classloader will consult 
  its parent (again, effectively the Java boot classloader), then either a single 
  prerequisite known to contribute classes in the package being queried then its 
  own classpath entries for the desired class.</p>
<p>The classloader determines whether to consult self or its prerequisites based 
  on its imported and required packages. This information is inferred from the 
  plug-in content in the case of legacy plug-ins and directly specified in the 
  case of new plug-ins. In either case, it is known <i>a priori</i> which classloaders 
  will supply the classes for which packages. This offers performance improvements 
  as well as a solution to the vexing problem of multiple prerequisites contributing 
  the same classes.</p>
<p>Take for example the case of Xerces and Xalan. Both contain various classes 
  from org.xml packages. Under the PSP model, the Xerces plug-in would see its 
  copy of these classes while the Xalan plug-in would see their copy. Since these 
  plug-ins need to communicate, ClassCastExceptions occur. Under the PP|S model, 
  only one of the two plug-ins contributes the duplicate classes and both plug-ins 
  see the same copies.</p>
<p><b>Action required:</b> The action required depends on the particulars of the 
  usecase. Affected developers need to review their classpath and resolve any 
  conflicts which may be happening.</p>
<h3>Default package content cannot be shared</h3>
<p><b>Who is affected:</b> Plug-ins which expect to use types or resources in 
  the default package of another plug-in. The use of the default package is very 
  rare. The only uses we have seen is where test suites use the default package 
  and <tt>getResource()</tt> to access test data.</p>
<p><b>Description:</b> The new Eclipse runtime allows plug-ins to contribute more 
  classpath information. This information is used to optimize classloading such 
  that searching arbitrarily long prerequisite chains is not required. The technique 
  used for specifying this information does not allow for the sharing of the default 
  package. As such, a plug-in's classloader is able to see the default package 
  in its own classpath but not in that of its prerequisite plug-ins.</p>
<p><b>Action required:</b> Plug-in developers should address this by moving such 
  files to non-root directories on their classpath. Note that moving them to say 
  <tt>icons/</tt> in the jar does not particularly help because the package &quot;icons&quot; 
  would typically be exported and would surely conflict with some other plug-in 
  doing the same. Also note that Java package naming rules do not allow for package 
  segments which contain whitespace. The best approach is to either put the files 
  in a real, unique, package or remove such files from the classpath and access 
  them via the <tt>Bundle.getEntry()</tt> API.</p>
<h3>PluginModel object casting</h3>
<p></p>
<p><b>Who is affected:</b> Plug-ins which cast objects of type IPlugin* to Plugin*Model. 
  Even though the relationship between these interfaces and the model classes 
  is not a specified part of the Eclipse 2.1 API we are explicitly calling out 
  this change as we have found that PDE and a few others are currently take advantaging 
  of the correlation in the 2.1 implementation. </p>
<p><b>Description:</b> The Eclipse API provides a series of interfaces (e.g., 
  <tt>IPluginDescriptor</tt>) and so-called &quot;model&quot; classes (e.g., <tt>PluginDescriptorModel</tt>) 
  related to plug-ins and the plug-in registry. In the Eclipse 2.1 implementation 
  it happens that the model classes implement the relevant interfaces. In the 
  new runtime the plug-in registry has been significantly reworked to allow for 
  a separation between the classloading and prerequisite aspects of plug-ins and 
  the extension and extension-point aspects. As such the Eclipse 3.0 runtims is 
  unable to maintain the implementation relationship present in 2.1.</p>
<p><b>Action required:</b> Developers currently relying on this non-API relationship 
  will need to rework their code according to their usecase. More information 
  on this is given in the recommended changes section of this document.</p>
<h3>Invalid assumptions regarding the form of URLs</h3>
<p><b>Who is affected:</b> Plug-ins which make assumptions regarding their installation 
  structure, location and the local file system layout.</p>
<p><b>Description:</b> Methods such as <tt>IPluginDescriptor.getInstallURL()</tt> 
  return URLs of a particular form. Despite this form not being specified, various 
  plug-ins make assumptions based on the current implementation. For example, 
  they may expect to get a <tt>file:</tt> URL and use URL.getFile() and use <tt>java.io.File</tt> 
  manipulation on the result. To date, this has been a workable but rather unsafe 
  approach. For example, if a plug-in is installed on a web server, it is possible 
  that an <tt>http:</tt> URL would be returned. The new Eclipse 3.0 runtime is 
  even more flexible and opens more possibilities for execution configurations 
  (e.g., maintaining whole plugins in JARs rather than exploded in directories). 
  That is , while new runtime does not actually break 2.1 API, it exposes more 
  cases where assumptions made in current plug-ins are invalid. </p>
<p><b>Action required:</b> Plug-in writers should ensure that the information 
  to which they need access is available via <tt>getResource()</tt> (and is on 
  the classpath) or use the relevant API for accessing the contents of a plug-in 
  (e.g., <tt>Bundle.getEntry(String)</tt>).</p>
<h3>BootLoader API removed</h3>
<p><b>Who is affected:</b> Plug-ins which use certain API from the class <tt>org.eclipse.core.boot.BootLoader</tt>.</p>
<p><b>Description:</b> Methods such as getRunnable(), startup(), shutdown() and 
  run() were removed from the BootLoader class supplied in the compatibility layer. 
</p>
<p><b>Action required:</b> In general this API is used by very few people. It 
  is intended as the interface between the main() in startup.jar and the Eclipse 
  runtime. Having said that, in some cases this removal was too eager and the 
  API should be added back. This is under investigation.</p>
<h3>Re-exporting runtime API</h3>
<p><b>Who is affected:</b> Plug-ins which expose API that includes elements from 
  changed runtime API.</p>
<p><b>Description:</b> Various plug-ins expose API that includes elements from 
  the runtime API. With the changes for the Eclipse 3.0 runtime, some of this 
  API has been deprecated. As such, the client plug-in's API will contain deprecated 
  elements. A concrete example is the Resources plug-in's IncrementalProjectBuilder 
  abstract class. This class is declared to implement org.eclipse.core.runtime.plugins.IExecutableExtension. 
  This interface has moved to be org.eclipse.core.registry.IExecutableExtension. 
  When the Resources plug-in is updated to use the new type, all existing builders 
  will be invalidated. In this case it is relatively straight forward to have 
  the abstract superclass use the new API and deprecate the old. Legacy builders 
  continue to work and the new API is available to new builders.</p>
<p><b>Action required:</b> The action required depends on the actual scenario. 
  One case is outlined above. Other cases may mandate an actual change in the 
  API of the client. Still others may force the client to continue being a user 
  of the compatibility layer.</p>
<h3>Plug-in parsing methods on Platform</h3>
<p><b>Who is affected:</b> Users of <tt>org.eclipse.core.runtime.Platform.parsePlugins(..., 
  Factory).</tt></p>
<p>Description: The method <tt>org.eclipse.core.runtime.Platform.parsePlugins(..., 
  Factory)</tt> has been deleted. The API associated with the Factory argument 
  has been deprecated and moved from the org.eclipse.core.runtime plug-in up to 
  the org.eclipse.core.runtime.compatibility plug-in (which depends on the runtime 
  plug-in). As such, any references to the Factory-related types cannot be resolved.</p>
<p><b>Action required:</b> Users of the deleted method can use the same method 
  on the class <tt>org.eclipse.core.runtime.CompatibilityPlatform</tt>. This requires 
  only that the reference to <tt>Platform</tt> be changed to <tt>CompatibilityPlatform</tt>.</p>
<h3>Changes to build scripts</h3>
<p><b>Who is affected:</b> Developers maintaining scripts (e.g., Ant build.xml 
  files) which define classpaths containing runtime related jars and class directories. 
</p>
<p><b>Description:</b> The new runtime contains a number of new plug-ins and jars. 
  Their introduction was mandated by the refactoring of the runtime into configurable 
  pieces. For most runtime situations these changes are transparent. However, 
  if you have custom build.xml (or similar) scripts which currently compile code 
  against <tt>org.eclipse.core.runtime</tt>, you will need to update them before 
  they will function correctly. A typical script contains a classpath entry in 
  a &lt;javac&gt; task that references the <tt>org.eclipse.core.runtime</tt> plug-in 
  as follows:</p>
<pre>    ../org.eclipse.core.runtime/bin;../org.eclipse.core.runtime/runtime.jar</pre>
<p>The runtime plug-in continues to contain much of the original runtime code. 
  However, all deprecated API is not contained in a compatibility plug-in (<tt>org.eclispe.core.runtime.compatibility</tt>) 
  and most of the new code is contained in a collection of plug-ins (<tt>org.eclipse.osgi.*</tt>). 
</p>
<p><b>Action required:</b> Developers should add the entries below as needed to 
  eliminate compilation errors. While the complete set of jars supplied is listed 
  below, typical uses require only a subset on the classpath at compile time. 
  As usual, the inclusion of the /bin directories is discretionary. The entries 
  are given here in logical groupings by supplying plug-in:</p>
<ul>
  <li>../org.eclipse.core.runtime.compatibility/bin;../org.eclipse.core.runtime.compatibility/compatibility.jar;</li>
  <li>../org.eclipse.osgi/bin;../org.eclipse.osgi/osgi.jar;../org.eclipse.osgi/core.jar; 
  </li>
  <li>../org.eclipse.update.configurator/bin;../org.eclipse.update.configurator/configurator.jar;</li>
  <li>../org.eclipse.osgi.util/util.jar;</li>
</ul>
<p>In addition the following jars may be required in special cases:</p>
<ul>
  <li> ../org.eclipse.osgi/resolver.jar; ../org.eclipse.osgi/defaultAdaptor.jar; 
    ../org.eclipse.osgi/eclipseAdaptor.jar; ../org.eclipse.osgi/console.jar</li>
</ul>
<p>While updating such scripts, you should also take the opportunity to clean 
  up (i.e., remove) references to <tt>org.eclipse.core.boot</tt>. This plug-in 
  is obsolete and longer contains any code. The entries can be left on the classpath 
  but they serve no purpose and should be removed. Look to remove:<br>
</p>
<pre>    ../org.eclipse.core.boot/bin;../org.eclipse.core.boot/boot.jar</pre>
<table border=0 cellspacing=0 cellpadding=2 width="100%" >
  <tr> 
    <td align=LEFT valign=TOP colspan="2" bgcolor="#0080C0"><b><font color="#FFFFFF"> 
      <a name="updating"></a>Recommended changes</font></b></td>
  </tr>
</table>
<p>The new runtime is 99% binary compatible with the original Eclipse runtime. 
  That is, with the exception of the cases listed above, <b>most existing plug-ins 
  will continue to run unchanged.</b> </p>
<p>Having said that, there are costs associated with the compatibilty layer and 
  the full power of the new runtime is not available to legacy plug-ins. Plug-in 
  developers interested in additional performance and function should consider 
  adopting the new APIs and removing their dependence on the compatibility layer.</p>
<p>As outlined above, the following plug-ins contain only deprecated code that 
  is no longer part of the official runtime API:</p>
<ul>
  <li>org.eclipse.core.boot</li>
  <li>org.eclipse.core.runtime.compatibility</li>
</ul>
<p>All of the code in these plug-ins has been marked as deprecated so you should 
  see compiler warnings if you are using the old function. If your code is typical 
  and has not been migrated, you will see a number of the deprecations listed 
  below. Also listed are the steps for updating your code to use the new API.</p>
<h3>Plug-ins and bundles</h3>
<p>The Eclipse runtime has been refactored into two parts; classloading and prerequisite 
  management, and extension/extension-point management. This split allows for 
  natural/seamless adoption of the OSGi framework specification for classloading 
  and prerequisite management. This in turn enables a range of new capabilities 
  in the runtime from dynamic plug-in install/update/uninstall to security and 
  increased configurability.</p>
<p>While we continue to talk about <i>plug-ins</i>, in the new runtime a plug-in 
  is really a <i>bundle</i> plus some extensions and extension-points. The term 
  <i>bundle</i> is defined by the OSGi framework specification and refers to a 
  collection of types and resources and associated inter-bundle prerequisite information. 
  The <i>extension registry</i> (and related types) is the new form of the plug-in 
  registry (and related types) and details only extension and extension-point 
  information. By-in-large the extension registry API is the same as the relevant 
  plug-in registry API (for more information see <a href="#registries">Registries</a>).</p>
<p>In the Eclipse 2.x runtime, the plug-in object has a number of roles and responsibilities:</p>
<ul>
  <li>Lifecycle - The <tt>Plugin</tt> class implements method such as startup() 
    and shutdown(). The runtime uses these methods to signal the plug-in that 
    someone is interested in the function it provides. In response, plug-ins typically 
    do a combination of: 
    <ul>
      <li>Registration - Hook various event mechanisms (e.g., register listeners) 
        and otherwise make their presence known in the system (e.g., start needed 
        threads). </li>
      <li>Initialization - Initialize or prime their data structures and load 
        models so they are ready for use.</li>
    </ul>
  </li>
  <li>Plug-in global data/function - While never explicitly put forth for this 
    role, in common practice plug-in classes have become a place to hang data 
    and function which is effectively global to the plug-in itself. In some cases 
    this data/function is API in others it is internal. For example, the UI plug-in 
    exposes as API methods such as <tt>getDialogSettings()</tt> and <tt>getWorkbench()</tt>.</li>
  <li>Context - The standard <tt>Plugin</tt> class provides access to various 
    runtime-provided function such as preferences and logging.</li>
</ul>
<p>In the Eclipse 3.0 runtime picture, these roles and responsibities are factored 
  somewhat into distinct objects.</p>
<dl> 
  <dt><b>Bundle</b></dt>
  <dd>Bundles are the OSGi unit of modularity. There is one classloader per bundle 
    and Eclipse-like inter-bundle class loading dependency graphs can be constructed. 
    Bundles have lifecycle for start and stop and the OSGi framework broadcasts 
    bundle related events (e.g., install, resolve, start, stop, uninstall, ...) 
    to interested parties. Unlike the Eclipse <tt>Plugin</tt> class, the OSGi 
    <tt>Bundle</tt> class is not extensible. That is, developers do not have the 
    opportunity to define their own bundle class.</dd>
  <dt><b>BundleActivator</b></dt>
  <dd>BundleActivator is an interface defined by the OSGi framework. Each bundle 
    can define a bundle activator class much like a plug-in can define its <tt>Plugin</tt> 
    class. This class is instantiated by the framework and used to implement the 
    <tt>start()</tt> and <tt>stop()</tt> lifecycle processing. There is a major 
    difference however in the nature of this lifecycle processing. In Eclipse 
    it is common (though not recommended) to have the <tt>Plugin</tt> classes 
    do both initialization and registration. In OSGi activators must only do registration. 
    Doing large amounts of initialization (or any other work) in <tt>BundleActivator.start()</tt> 
    threatens the liveness of the system.</dd>
  <dt><b>BundleContext</b></dt>
  <dd>BundleContexts are the OSGi mechanism for exposing general system function 
    to individual bundles. Each bundle has a unique and private instance of BundleContext 
    which they can use to access system function (e.g., getBundles() to discover 
    all bundles in the system).</dd>
  <dt><b>Plugin</b></dt>
  <dd><tt>BundleHelper</tt> is an Eclipse class designed to file the gap between 
    <tt>Plugin</tt> and <tt>Bundle/BundleContext</tt>. It provides methods such 
    as <tt>getLog()</tt> and <tt>getStateLocation()</tt> which were previously 
    found on <tt>Plugin</tt>.</dd>
</dl>
<p>The steps required to port a 2.x <tt>Plugin</tt> class to Eclipse 3.0 depends 
  on what the class is doing. As outlined above, most startup lifecycle work falls 
  into one of the following categories:</p>
<dl> 
  <dt><b>Initialization</b></dt>
  <dd>Datastructure and model initialization is quite often done in <tt>Plugin.startup()</tt>. 
    The natural/obvious mapping would be to do this work in <tt>BundleActivator.start()</tt>. 
    <b>This is strongly discouraged.</b> As with plug-ins, bundles may be started 
    for many different reasons in many different circumstances. Unless is it utterly 
    impossible for <i>any</i> of a plug-in/bundle's function to be used without 
    such initialization, it should not be done in <tt>startup()/start()</tt>. 
    <p> A classic real-world example from Eclipse 2.0 days is a plug-in which 
      initialized a large model requiring the loading of some 11MB of <i>code</i> 
      and many megabytes of data. There were quite common usecases where this 
      plug-in was activated to discover if the project icon presented in the navigator 
      should be decorated with a little check mark. This test did not require 
      any of the initialization done in <tt>startup()</tt> but yet all users, 
      in all usecases had to pay the memory and time penalty for this eager initialization.</p>
The alternative approach is to do such initialization in a classic lazy style. 
    For example, rather than having models initialized when the plug-in/bundle 
    is activated, do it when they are actually needed (e.g., in a centralized 
    model accessor method). For many usecases this will amount to nearly the same 
    point in time but for other scenarios this approach will defer initialization 
    (perhaps indefinitely). We recommend taking time while porting 2.1 plug-ins 
    to reconsider the initialization strategy used.</dd>
  <dt><b>Registration</b></dt>
  <dd>Plug-in startup is a convenient time to register listeners, services etc. 
    and start background processing threads (e.g., listening on a socket). The 
    startup()/start() method is a reasonable place to do this work. It may also 
    make sense to defer until some other trigger (e.g., the use of a particular 
    function or data element).</dd>
</dl>
<p>&nbsp;</p>
<p>Scenarios</p>
<p>No plugin class</p>
<p>initialization</p>
<p>registration </p>
<p>initialization + registration</p>
<p>&nbsp;</p>
<p>Because Eclipse 3.0 runs on top of OSGi, plugins have been seamlessly integrated 
  with bundles.<br>
  The immediate consequences are a restructuration of plugins and some subtle 
  differences in the lifecycle of plugins. <br>
  In order to make clear what we are talking about, we will use 'plugin' to refer 
  to the eclipse 2.1 concepts and before, whereas bundle will refer to the new 
  model in Eclipse 3.0.</p>
<p>One important modification is in the separation of the activation code from 
  the 'state'. <br>
  In eclipse 2.1, the plugin class was being used both as a state keeper accessible 
  from anywhere in the system, and as a life cycle handler. This merge was making 
  easier the mixup of the two concepts resulting in too heavy initialization code.</p>
<p>A Bundle is an object is a system object, and can not be customized. The bundle 
  object can actually be assimilated to the IPluginDescriptor for all the information 
  describing the bundle. The information about extension and extension points 
  are now accessible from an IExtensionRegistry.</p>
<p>&nbsp;</p>
<p>Now bundles may have an activator class whose role is to initialize and uninitialize 
  the state of bundle. This activator must be lightweight. It should simply try 
  to declare and acquire services, and initialize basic data structures. This 
  promotes the lazy initialization of most of the data structures.</p>
<p>Platform</p>
<ul>
  <li>IPlatform</li>
  <li>how to get access. (via the bundlehelper)</li>
  <li>new API</li>
</ul>
<p>Plug-ins and bundles</p>
<ul>
  <li>bundle is defined by the system</li>
  <li>activator classes are the closest thing to plugin classes</li>
  <li>file structure</li>
  <li>install locations etc</li>
  <li>how to get the bundle</li>
  <li>extensions registry </li>
  <li>bundle descriptions from the state (this is dangerous if we want to unload 
    the state)</li>
  <li>bundlehelper</li>
  <li>singletons usecases fro how to map a plugin into a combo of activator and 
    helper</li>
  <li>what is a context 
    <ul>
      <li>don't share</li>
    </ul>
  </li>
  <li>where to put the startup code (activator vs plugin.startup)</li>
  <li>plugin descriptor is now a bundle</li>
  <li>import/export package???</li>
  <li>
    <p>manifest reorg</p>
    
  </li>
</ul>
<p>Plugin Model</p>
<ul>
  <li>where did it go?</li>
</ul>
<p>Startup sequence</p>
<p>&nbsp;</p>
<h4>Class/Package name changes</h4>
<p>&nbsp;</p>
<h3>Deprecations</h3>
All of the plugin registry model API 
<h4>org.eclipse.core.runtime.ILibrary (class)</h4>
<p> In the original runtime, ILibrary is a representation of execution related 
  attributes. In the new runtime these are now handled by OSGi. While it is possible 
  to maintain some of the API for legacy plug-ins, it is not possible to do so 
  for OSGi-based plug-ins/bundles. Users of ILibrary should consider using Bundle.getHeader(Constants.BUNDLE_CLASSPATH) 
  and processing the results using the ManifestElement helper class.</p>
<h4>org.eclipse.core.runtime.IPrerequisite (class)</h4>
<p>In the original runtime, IPrerequisite is a representation of execution related 
  attributes. In the new runtime these are now handled by OSGi. While it is possible 
  to maintain some of the API for legacy plug-ins, it is not possible to do so 
  for OSGi-based plug-ins/bundles. Users of IPrerequiste should consider using 
  Bundle.getHeader(Constants.IMPORT_PACKAGE) or Bundle.getHeader(Constants.REQUIRE_BUNDLE) 
  and processing the results using the ManifestElement helper class.</p>
<h4></h4>
<h4>org.eclipse.core.runtime.Platform (methods)</h4>
<ul>
  <li>getPlugin(String)</li>
  <li>getPluginRegistry()</li>
  <li>getPluginStateLocation(Plugin)</li>
</ul>
<h4>org.eclipse.core.runtime.Plugin (methods)</h4>
<ul>
  <li>Plugin(IPluginDescriptor)</li>
  <li>getPluginDescriptor()</li>
  <li>getPluginPreferences()</li>
  <li>savePluginPreferences()</li>
  <li>initializeDefaultPluginPreferences()</li>
  <li>shutdown()</li>
  <li>startup()</li>
</ul>
<h4>org.eclipse.core.runtime.IExtension<br>
  org.eclipse.core.runtime.IExtensionPoint (methods) </h4>
<ul>
  <li>IExtension.getDeclaringPlugin()<br>
    IExtensionPoint.getDeclaringPlugin() give upward links to the plug-in which 
    declares the extension or extension-point (respectively). The new registry 
    model separates the execution aspects of plug-ins from the extension/extension-point 
    aspects and no longer contains IPluginDescriptors. Users of this API should 
    consider the new method getParentIdentifier() found on both IExtension and 
    IExtensionPoint. The returned value can be used directly or as a key in the 
    compatibility IPluginRegistry or the OSGi framework's API for bundle discovery 
    (e.g., BundleContext.getBundles(String)).</li>
</ul>
<h4>org.eclipse.core.runtime.IPluginRegistry (class)</h4>
<p>The contents of the plug-in registry, like the runtime, has been split into 
  two parts, the execution-related and the extension-related. As such, the unified 
  notion of a plug-in registry does not apply. Uses of the IPluginRegistry to 
  discover extensions and extension-points are directly supported by nearly identical 
  API on IExtensionRegistry. Uses of IPluginRegistry to discover IPluginDescriptors 
  should be changed to use the appropriate OSGi structures. See the discussion 
  related to IPluginDescriptor for more details.</p>
<h4>org.eclipse.core.runtime.IPluginDescriptor (class)</h4>
<p>Plug-in descriptors contain methods for a number of different purposes. These 
  are outlined below as well as the steps for updating their uses.</p>
<dl> 
  <dt><b>extension-related</b> (e.g., getExtensions())</dt>
  <dd>sdf</dd>
  <dt><b>execution-related</b> (e.g., find() and getPluginClassLoader())</dt>
  <dd>sdf</dd>
  <dt> <b>accessors</b> (e.g., getLabel())</dt>
  <dd>sdfsfd</dd>
</dl>
<p>&nbsp;</p>
<h4>org.eclipse.core.runtime.model (package)</h4>
<p>The plug-in registry has been deprecated </p>
<p>Extension-related uses are updated by accessing the extension registry directly. 
</p>
<p>&nbsp;</p>
<a name="registries"></a>Registries 
<p>In the new runtime there is a separation between the information and structures 
  needed to run a plug-in and that related to a plug-in's extensions and extension 
  points. The former is defined and managed by the OSGi framework specification. 
  The latter are Eclipse-specific concepts and are added by they Eclipse runtime 
  code. Accordingly, the original plugin registy and related objects have been 
  split into OSGi <i>bundles</i> and the Eclipse <i>extension registry</i>. </p>
<p>The OSGi framework API defines ways of discovering and interrogating bundles. 
  Methods such as BundleContext.getBundles() </p>
<h3>Updating plugin.xml and fragment.xml</h3>
<p>The new runtime is based on an implementation of the OSGi framework specification. 
  The OSGi specification mandates the use of manifest.mf files to define the execution 
  of a plug-in. This conflicts with the Eclipse notion of plugin.xml as far as 
  &lt;runtime&gt; and &lt;requires&gt; elements are concerned. The easiest way 
  to update your plugin.xml or fragment.xml is to use the PDE Migration Tool (PDE 
  Tools-&gt;Convert to OSGi bundle).</p>
<h3>Build-related issues</h3>
<p><b>Who is affected:</b> Writers of bundles who want to make those bundles available 
  people using plug-in oriented tooling.</p>
<p><b>Description:</b> Current build structures (e.g., PDE, custom builds done 
  by product teams, ...) are based on plug-ins, fragments and features. While 
  the new runtime supports these components, it is bundle based. To support existing 
  build structures we (and other bundle developers) must take care to include 
  plugin.xml and fragment.xml files (as appropriate) for all bundles. This allows 
  the tooling and build mechanisms to correctly interpret the content of the bundle 
  and make it available.</p>
<p><b>Analysis:</b> By maintaining the plugin.xml content, tooling and build mechanisms 
  will continue to function. As these are updated to handle the new structures, 
  the need to maintain plugin.xml and fragment.xml files will diminish.</p>
<p>&nbsp;</p>
<table border=0 cellspacing=0 cellpadding=2 width="100%" >
  <tr> 
    <td align=LEFT valign=TOP colspan="2" bgcolor="#0080C0"><b><font color="#FFFFFF"> 
      Feedback</font></b></td>
  </tr>
</table>
<p> Should you encounter any problems while using the Equinox runtime, you are 
  encouraged to either log a bug report in the <a href="https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Equinox">Equinox 
  Bugzilla database</a> or make a posting to the Core <a href="http://dev.eclipse.org/mailman/listinfo/platform-core-dev">mailing 
  list</a> or the Platform <a href="news://news.eclipse.org/eclipse.platform">newsgroup</a>. 
</p>
</body>
</html>
