<html>
<head>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<title>Eclipse 3.0 Runtime Porting Guide</title>
		<link rel="stylesheet" title="default" href="http://eclipse.org/default_style.css" type="text/css">
		<style>
			th,td { vertical-align:top; text-align=left}
			.issue { font-style:oblique; width:200px;}
			.box	{ background-color:#E0E0FF}
		</style>
	</head>
	<body>
		<table BORDER=0 CELLSPACING=5 CELLPADDING=2 WIDTH="100%" >
			<tr> 
				<td ALIGN=left width="60%">
					
      <p><font class=indextop> eclipse</font><br>
        <font class=indexsub> eclipse 3.0 runtime porting guide</font> </p>
				</td>
				<td WIDTH="40%">&nbsp; </td>
			</tr>
		</table>

<blockquote> 
  <p><b>Summary</b> <br>
    This document details how to move from running the runtime in Eclipse 2.x 
    to using the new runtime included in Eclipse 3.0. Included here is information 
    on required and recommended changes to Eclipse 2.x plug-in writers to make 
    them run in the Eclipse 3.0 environment. Information on how to use the new 
    runtime is contained in the <a href="howto.html">Users Guide</a>.<br>
    Last Modified: 0100 December 8, 2003</p>
  
</blockquote>

<table border=0 cellspacing=0 cellpadding=2 width="100%" >
  <tr> 
    <td align=LEFT valign=TOP colspan="2" bgcolor="#0080C0"><b><font color="#FFFFFF"> 
      Required changes</font></b></td>
  </tr>
</table>
<p> Below is a list of the changes which must be carried out on Eclipse 2.x plug-ins 
  to allow them to function correctly in an Eclipse 3.0 environment. The Eclipse 
  3.0 runtime includes a compatibility layer which is 99% binary compatible with 
  Eclipse 2.1. As such, very few plug-ins should actually require updating. The 
  information below details who is affected by the changes as well as what action 
  needs to be taken. </p>
<h3>URL Stream Handler extensions</h3>
<p><b>Who is affected:</b> Plug-ins which contribute extensions to the <tt>org.eclipse.core.runtime.urlHandlers</tt> 
  extension point. While useful, it appears that very few plug-ins have a need 
  for this facility. Eclipse itself uses it and a quick scan of major Eclipse-based 
  products (e.g., WSAD) uncovered one or two more.</p>
<p><b>Description:</b> OSGi provides a URL Stream Handler service much like that 
  supported by Eclipse runtime which allows for the registration of URL stream 
  handlers for different URL protocols (e.g., jndi: URLs). The OSGi support is 
  superior to that in Eclipse 2.1 in that it correctly handles dynamic handlers 
  (i.e., ones which come and go). Because of various design issues with the base 
  Java URL handler mechanism, URLStreamHandlers registered with the OSGi handler 
  service must implement <tt>org.osgi.service.url.URLStreamHandlerService</tt>. 
  The OSGi framework provides a handy abstract superclass (<tt>org.osgi.service.url.AbstractURLStreamHandlerService</tt>) 
  that does the bulk of this work. </p>
<p><b>Action required:</b> Unfortunately, legacy plug-ins which supply URL handler 
  contributions (extensions to the <tt>org.eclipse.core.runtime.urlHandlers</tt> 
  extension point) implement only the <tt>java.net.URLStreamHandler</tt> contract. 
  Since all of the methods on URLStreamHandler are protected, it is not possible 
  for the runtime compatibility layer to simply wrap such handlers to and give 
  them the required behaviour. Rather, the implementation of your handler must 
  be updated either to implement <tt>org.osgi.service.url.URLStreamHandlerService</tt> 
  or to extend <tt>org.osgi.service.url.AbstractURLStreamHandlerService</tt>.</p>
<h3>Classload order</h3>
<p><b>Who is affected:</b> Plug-ins which supply packages provided which are also 
  supplied by other plug-ins. A very limited number of plug-ins are affected by 
  this change and some of those affected will actually benefit (see below).</p>
<p><b>Description:</b> In Eclipse 2.x, classloaders search for classes using the 
  so-called <i>PSP</i> ordering. That is, a given classloader would first consult 
  its <b>p</b>arent classloader (in practice this is the Java boot classloader), 
  then its own classpath contents (i.e., <b>s</b>elf) and finally all of its <b>p</b>rerequisites 
  in declared order. OSGi offers an optimization over this model, the so-called 
  <i>PP|S</i> (read P, P or S) ordering. In this approach a classloader will consult 
  its parent (again, effectively the Java boot classloader), then either a single 
  prerequisite known to contribute classes in the package being queried then its 
  own classpath entries for the desired class.</p>
<p>The classloader determines whether to consult self or its prerequisites based 
  on its imported and required packages. This information is inferred from the 
  plug-in content in the case of legacy plug-ins and directly specified in the 
  case of new plug-ins. In either case, it is known <i>a priori</i> which classloaders 
  will supply the classes for which packages. This offers performance improvements 
  as well as a solution to the vexing problem of multiple prerequisites contributing 
  the same classes.</p>
<p>Take for example the case of Xerces and Xalan. Both contain various classes 
  from org.xml packages. Under the PSP model, the Xerces plug-in would see its 
  copy of these classes while the Xalan plug-in would see their copy. Since these 
  plug-ins need to communicate, ClassCastExceptions occur. Under the PP|S model, 
  only one of the two plug-ins contributes the duplicate classes and both plug-ins 
  see the same copies.</p>
<p><b>Action required:</b> The action required depends on the particulars of the 
  usecase. Affected developers need to review their classpath and resolve any 
  conflicts which may be happening.</p>
<h3>Default package content cannot be shared</h3>
<p><b>Who is affected:</b> Plug-ins which expect to use types or resources in 
  the default package of another plug-in. The use of the default package is very 
  rare. The only uses we have seen is where test suites use the default package 
  and <tt>getResource()</tt> to access test data.</p>
<p><b>Description:</b> The new Eclipse runtime allows plug-ins to contribute more 
  classpath information. This information is used to optimize classloading such 
  that searching arbitrarily long prerequisite chains is not required. The technique 
  used for specifying this information does not allow for the sharing of the default 
  package. As such, a plug-in's classloader is able to see the default package 
  in its own classpath but not in that of its prerequisite plug-ins.</p>
<p><b>Action required:</b> Plug-in developers should address this by moving such 
  files to non-root directories on their classpath. Note that moving them to say 
  <tt>icons/</tt> in the jar does not particularly help because the package &quot;icons&quot; 
  would typically be exported and would surely conflict with some other plug-in 
  doing the same. Also note that Java package naming rules do not allow for package 
  segments which contain whitespace. The best approach is to either put the files 
  in a real, unique, package or remove such files from the classpath and access 
  them via the <tt>Bundle.getEntry()</tt> API.</p>
<h3>PluginModel object casting</h3>
<p></p>
<p><b>Who is affected:</b> Plug-ins which cast objects of type IPlugin* to Plugin*Model. 
  Even though the relationship between these interfaces and the model classes 
  is not a specified part of the Eclipse 2.1 API we are explicitly calling out 
  this change as we have found that PDE and a few others are currently take advantaging 
  of the correlation in the 2.1 implementation. </p>
<p><b>Description:</b> The Eclipse API provides a series of interfaces (e.g., 
  <tt>IPluginDescriptor</tt>) and so-called &quot;model&quot; classes (e.g., <tt>PluginDescriptorModel</tt>) 
  related to plug-ins and the plug-in registry. In the Eclipse 2.1 implementation 
  it happens that the model classes implement the relevant interfaces. In the 
  new runtime the plug-in registry has been significantly reworked to allow for 
  a separation between the classloading and prerequisite aspects of plug-ins and 
  the extension and extension-point aspects. As such the Eclipse 3.0 runtims is 
  unable to maintain the implementation relationship present in 2.1.</p>
<p><b>Action required:</b> Developers currently relying on this non-API relationship 
  will need to rework their code according to their usecase. More information 
  on this is given in the recommended changes section of this document.</p>
<h3>Invalid assumptions regarding the form of URLs</h3>
<p><b>Who is affected:</b> Plug-ins which make assumptions regarding their installation 
  structure, location and the local file system layout.</p>
<p><b>Description:</b> Methods such as <tt>IPluginDescriptor.getInstallURL()</tt> 
  return URLs of a particular form. Despite this form not being specified, various 
  plug-ins make assumptions based on the current implementation. For example, 
  they may expect to get a <tt>file:</tt> URL and use URL.getFile() and use <tt>java.io.File</tt> 
  manipulation on the result. To date, this has been a workable but rather unsafe 
  approach. For example, if a plug-in is installed on a web server, it is possible 
  that an <tt>http:</tt> URL would be returned. The new Eclipse 3.0 runtime is 
  even more flexible and opens more possibilities for execution configurations 
  (e.g., maintaining whole plugins in JARs rather than exploded in directories). 
  That is , while new runtime does not actually break 2.1 API, it exposes more 
  cases where assumptions made in current plug-ins are invalid. </p>
<p><b>Action required:</b> Plug-in writers should ensure that the information 
  to which they need access is available via <tt>getResource()</tt> (and is on 
  the classpath) or use the relevant API for accessing the contents of a plug-in 
  (e.g., <tt>Bundle.getEntry(String)</tt>).</p>
<h3>BootLoader API removed</h3>
<p><b>Who is affected:</b> Plug-ins which use certain API from the class <tt>org.eclipse.core.boot.BootLoader</tt>.</p>
<p><b>Description:</b> Methods such as getRunnable(), startup(), shutdown() and 
  run() were removed from the BootLoader class supplied in the compatibility layer. 
</p>
<p><b>Action required:</b> In general this API is used by very few people. It 
  is intended as the interface between the main() in startup.jar and the Eclipse 
  runtime. Having said that, in some cases this removal was too eager and the 
  API should be added back. This is under investigation.</p>
<h3>Re-exporting runtime API</h3>
<p><b>Who is affected:</b> Plug-ins which expose API that includes elements from 
  changed runtime API.</p>
<p><b>Description:</b> Various plug-ins expose API that includes elements from 
  the runtime API. With the changes for the Eclipse 3.0 runtime, some of this 
  API has been deprecated. As such, the client plug-in's API will contain deprecated 
  elements. A concrete example is the Resources plug-in's IncrementalProjectBuilder 
  abstract class. This class is declared to implement org.eclipse.core.runtime.plugins.IExecutableExtension. 
  This interface has moved to be org.eclipse.core.registry.IExecutableExtension. 
  When the Resources plug-in is updated to use the new type, all existing builders 
  will be invalidated. In this case it is relatively straight forward to have 
  the abstract superclass use the new API and deprecate the old. Legacy builders 
  continue to work and the new API is available to new builders.</p>
<p><b>Action required:</b> The action required depends on the actual scenario. 
  One case is outlined above. Other cases may mandate an actual change in the 
  API of the client. Still others may force the client to continue being a user 
  of the compatibility layer.</p>
<h3>Plug-in parsing methods on Platform</h3>
<p><b>Who is affected:</b> Users of <tt>org.eclipse.core.runtime.Platform.parsePlugins(..., 
  Factory).</tt></p>
<p>Description: The method <tt>org.eclipse.core.runtime.Platform.parsePlugins(..., 
  Factory)</tt> has been deleted. The API associated with the Factory argument 
  has been deprecated and moved from the org.eclipse.core.runtime plug-in up to 
  the org.eclipse.core.runtime.compatibility plug-in (which depends on the runtime 
  plug-in). As such, any references to the Factory-related types cannot be resolved.</p>
<p><b>Action required:</b> Users of the deleted method can use the same method 
  on the class <tt>org.eclipse.core.runtime.CompatibilityPlatform</tt>. This requires 
  only that the reference to <tt>Platform</tt> be changed to <tt>CompatibilityPlatform</tt>.</p>
<h3>Changes to build scripts</h3>
<p><b>Who is affected:</b> Developers maintaining scripts (e.g., Ant build.xml 
  files) which define classpaths containing runtime related jars and class directories. 
</p>
<p><b>Description:</b> The new runtime contains a number of new plug-ins and jars. 
  Their introduction was mandated by the refactoring of the runtime into configurable 
  pieces. For most runtime situations these changes are transparent. However, 
  if you have custom build.xml (or similar) scripts which currently compile code 
  against <tt>org.eclipse.core.runtime</tt>, you will need to update them before 
  they will function correctly. A typical script contains a classpath entry in 
  a &lt;javac&gt; task that references the <tt>org.eclipse.core.runtime</tt> plug-in 
  as follows:</p>
<pre>    ../org.eclipse.core.runtime/bin;../org.eclipse.core.runtime/runtime.jar</pre>
<p>The runtime plug-in continues to contain much of the original runtime code. 
  However, all deprecated API is not contained in a compatibility plug-in (<tt>org.eclispe.core.runtime.compatibility</tt>) 
  and most of the new code is contained in a collection of plug-ins (<tt>org.eclipse.osgi.*</tt>). 
</p>
<p><b>Action required:</b> Developers should add the entries below as needed to 
  eliminate compilation errors. While the complete set of jars supplied is listed 
  below, typical uses require only a subset on the classpath at compile time. 
  As usual, the inclusion of the /bin directories is discretionary. The entries 
  are given here in logical groupings by supplying plug-in:</p>
<ul>
  <li>../org.eclipse.core.runtime.compatibility/bin;../org.eclipse.core.runtime.compatibility/compatibility.jar;</li>
  <li>../org.eclipse.osgi/bin;../org.eclipse.osgi/osgi.jar;</li>
  <li>../org.eclipse.update.configurator/bin;../org.eclipse.update.configurator/configurator.jar;</li>
  <li>../org.eclipse.osgi.util/util.jar;</li>
</ul>
<p>In addition the following jars may be required in special cases:</p>
<ul>
  <li> ../org.eclipse.osgi/core.jar; ../org.eclipse.osgi/resolver.jar; ../org.eclipse.osgi/defaultAdaptor.jar; 
    ../org.eclipse.osgi/eclipseAdaptor.jar; ../org.eclipse.osgi/console.jar</li>
</ul>
<p>While updating such scripts, you should also take the opportunity to clean 
  up (i.e., remove) references to <tt>org.eclipse.core.boot</tt>. This plug-in 
  is obsolete and longer contains any code. The entries can be left on the classpath 
  but they serve no purpose and should be removed. Look to remove:<br>
</p>
<pre>    ../org.eclipse.core.boot/bin;../org.eclipse.core.boot/boot.jar</pre>
<table border=0 cellspacing=0 cellpadding=2 width="100%" >
  <tr> 
    <td align=LEFT valign=TOP colspan="2" bgcolor="#0080C0"><b><font color="#FFFFFF"> 
      <a name="updating"></a>Recommended changes</font></b></td>
  </tr>
</table>
<p>The new runtime is 99% binary compatible with the original Eclipse runtime. 
  That is, with the exception of the cases listed above, <b>most existing plug-ins 
  will continue to run unchanged.</b> </p>
<p>Having said that, there are costs associated with the compatibilty layer and 
  the full power of the new runtime is not available to legacy plug-ins. Plug-in 
  developers interested in additional performance and function should consider 
  adopting the new APIs and removing their dependence on the compatibility layer.</p>
<p>As outlined above, the following plug-ins contain only deprecated code that 
  is no longer part of the official runtime API:</p>
<ul>
  <li>org.eclipse.core.boot</li>
  <li>org.eclipse.core.runtime.compatibility</li>
</ul>
<p>All of the code in these plug-ins has been marked as deprecated so you should 
  see compiler warnings if you are using the old function. If your code is typical 
  and has not been migrated, you will see a number of the deprecations listed 
  below. Also listed are the steps for updating your code to use the new API.</p>
<h3>Plug-ins and bundles</h3>
<p>The Eclipse runtime has been refactored into two parts; classloading and prerequisite 
  management, and extension/extension-point management. This split allows for 
  natural/seamless adoption of the OSGi framework specification for classloading 
  and prerequisite management. This in turn enables a range of new capabilities 
  in the runtime from dynamic plug-in install/update/uninstall to security and 
  increased configurability.</p>
<p>While we continue to talk about <i>plug-ins</i>, in the new runtime a plug-in 
  is really a <i>bundle</i> plus some extensions and extension-points. The term 
  <i>bundle</i> is defined by the OSGi framework specification and refers to a 
  collection of types and resources and associated inter-bundle prerequisite information. 
  The <i>extension registry</i> (and related types) is the new form of the plug-in 
  registry (and related types) and details only extension and extension-point 
  information. By-in-large the extension registry API is the same as the relevant 
  plug-in registry API (for more information see <a href="#registries">Registries</a>).</p>
<p>In the Eclipse 2.x runtime, the plug-in object has a number of roles and responsibilities:</p>
<ul>
  <li>Lifecycle - The <tt>Plugin</tt> class implements method such as startup() 
    and shutdown(). The runtime uses these methods to signal the plug-in that 
    someone is interested in the function it provides. In response, plug-ins typically 
    do a combination of: 
    <ul>
      <li>Registration - Hook various event mechanisms (e.g., register listeners) 
        and otherwise make their presence known in the system (e.g., start needed 
        threads). </li>
      <li>Initialization - Initialize or prime their data structures and load 
        models so they are ready for use.</li>
    </ul>
  </li>
  <li>Plug-in global data/function - While never explicitly put forth for this 
    role, in common practice plug-in classes have become a place to hang data 
    and function which is effectively global to the plug-in itself. In some cases 
    this data/function is API in others it is internal. For example, the UI plug-in 
    exposes as API methods such as <tt>getDialogSettings()</tt> and <tt>getWorkbench()</tt>.</li>
  <li>Context - The standard <tt>Plugin</tt> class provides access to various 
    runtime-provided function such as preferences and logging.</li>
</ul>
<p>In the Eclipse 3.0 runtime picture, these roles and responsibilities are factored 
  into distinct objects.</p>
<dl> 
  <dl>
    <dt><b>Bundle</b></dt>
    <dd>Bundles are the OSGi unit of modularity. There is one classloader per 
      bundle and Eclipse-like inter-bundle class loading dependency graphs can 
      be constructed. Bundles have lifecycle for start and stop and the OSGi framework 
      broadcasts bundle related events (e.g., install, resolve, start, stop, uninstall, 
      ...) to interested parties. Unlike the Eclipse <tt>Plugin</tt> class, the 
      OSGi <tt>Bundle</tt> class is not extensible. That is, developers do not 
      have the opportunity to define their own bundle class.</dd>
    <dt><b>BundleActivator</b></dt>
    <dd>BundleActivator is an interface defined by the OSGi framework. Each bundle 
      can define a bundle activator class much like a plug-in can define its <tt>Plugin</tt> 
      class. This class is instantiated by the framework and used to implement 
      the <tt>start()</tt> and <tt>stop()</tt> lifecycle processing. There is 
      a major difference however in the nature of this lifecycle processing. In 
      Eclipse it is common (though not recommended) to have the <tt>Plugin</tt> 
      classes do both initialization and registration. In OSGi activators must 
      only do registration. Doing large amounts of initialization (or any other 
      work) in <tt>BundleActivator.start()</tt> threatens the liveness of the 
      system.</dd>
    <dt><b>BundleContext</b></dt>
    <dd>BundleContexts are the OSGi mechanism for exposing general system function 
      to individual bundles. Each bundle has a unique and private instance of 
      BundleContext which they can use to access system function (e.g., getBundles() 
      to discover all bundles in the system).</dd>
    <dt><b>Plugin</b></dt>
    <dd>The new <tt>Plugin</tt> is very much like the original Eclipse <tt>Plugin</tt> 
      class with the following exceptions: <tt>Plugin</tt> objects are no longer 
      a) required or b) managed by the runtime and various methods have been deprecated 
      (see below). As such, Plugin continues to provide context access. It is 
      essentially a convenience mechanism providing a host of useful function 
      and mechanisms but is no longer absolutely required. Much of the function 
      provided there is also available on the <tt>Platform</tt> class in the runtime. 
      <p><tt>Plugin</tt> also implements <tt>BundleActivator</tt>. This recognizes 
        the convenience of having one central object representing the lifecycle 
        and semantic of a plug-in. Note that this does not however sanction the 
        eager initialization of data structures that is common in plug-ins today. 
        We cannot stress enough that plug-ins can be activated because a somewhat 
        peripheral class was referenced during verification of a class in some 
        other plug-in. That is, just because your plug-in has been activated does 
        not necessarily mean that its function is needed. Note also that you are 
        free to define a different <tt>BundleActivator</tt> class or not have 
        a bundle activator at all.</p>
    </dd>
  </dl>
</dl>
<p>The steps required to port a 2.x <tt>Plugin</tt> class to Eclipse 3.0 depends 
  on what the class is doing. As outlined above, most startup lifecycle work falls 
  into one of the following categories:</p>
<dl> 
  <dl>
    <dt><b>Initialization</b></dt>
    <dd>Datastructure and model initialization is quite often done in <tt>Plugin.startup()</tt>. 
      The natural/obvious mapping would be to do this work in a <tt>BundleActivator.start()</tt>, 
      that is to leave the function on <tt>Plugin</tt>. <b> This is strongly discouraged.</b> 
      As with 2.x plug-ins, 3.0 plug-ins/bundles may be started for many different 
      reasons in many different circumstances. <br>
      An actual example from Eclipse 2.0 days illuminates this case. There was 
      a plug-in which initialized a large model requiring the loading of some 
      11MB of <i>code</i> and many megabytes of data. There were quite common 
      usecases where this plug-in was activated to discover if the project icon 
      presented in the navigator should be decorated with a particular markup. 
      This test did not require any of the initialization done in <tt>startup()</tt> 
      but yet all users, in all usecases had to pay the memory and time penalty 
      for this eager initialization.<br>
      The alternative approach is to do such initialization in a classic lazy 
      style. For example, rather than having models initialized when the plug-in/bundle 
      is activated, do it when they are actually needed (e.g., in a centralized 
      model accessor method). For many usecases this will amount to nearly the 
      same point in time but for other scenarios this approach will defer initialization 
      (perhaps indefinitely). We recommend taking time while porting 2.1 plug-ins 
      to reconsider the initialization strategy used. </dd>
    <dt><b>Registration</b></dt>
    <dd>Plug-in startup is a convenient time to register listeners, services etc. 
      and start background processing threads (e.g., listening on a socket). <tt>Plugin.start()</tt> 
      may a reasonable place to do this work. It may also make sense to defer 
      until some other trigger (e.g., the use of a particular function or data 
      element).</dd>
    <dt><b>Plug-in global data</b></dt>
    <dd>Your <tt>Plugin</tt> class can continue to play this role. The main issue 
      is that <tt>Plugin</tt> objects are no longer globally accessible via a 
      system-managed list. In Eclipse 2.x you could discover any plug-in's <tt>Plugin</tt> 
      ojbect via the plug-in registry. This is no longer possible. In most circumstances 
      this type of access is not required. <tt>Plugins</tt> accessed via the registry 
      are more typically used as generic <tt>Plugins</tt> rather than calling 
      domain-specific methods.</dd>
  </dl>
</dl>
<h4>Scenarios</h4>
<p>No plugin class</p>
<p>initialization</p>
<p>registration </p>
<p>initialization + registration</p>
<h3><a name="registries"></a>Registries </h3>
<p>In the new runtime there is a separation between the information and structures 
  needed to execute a plug-in and that related to a plug-in's extensions and extension 
  points. The former is defined and managed by the OSGi framework specification. 
  The latter are Eclipse-specific concepts and are added by they Eclipse runtime 
  code. Accordingly, the original plug-in registy and related objects have been 
  split into OSGi <i>bundles</i> and the Eclipse <i>extension registry</i>. </p>
<p>The OSGi framework API defines ways of discovering and interrogating bundles. 
  Methods such as BundleContext.getBundles() </p>
<h3></h3>
<h3>Plugin Model</h3>
<ul>
  <li>where did it go?</li>
</ul>
<h3>Deprecations</h3>
<h4>org.eclipse.core.runtime.ILibrary (class)</h4>
<p> In the original runtime, ILibrary is a representation of execution related 
  attributes. In the new runtime these are now handled by OSGi. While it is possible 
  to maintain some of the API for legacy plug-ins, it is not possible to do so 
  for OSGi-based plug-ins/bundles. Users of ILibrary should consider using Bundle.getHeader(Constants.BUNDLE_CLASSPATH) 
  and processing the results using the ManifestElement helper class.</p>
<h4>org.eclipse.core.boot.BootLoader (class)</h4>
<p>BootLoader has been completely deprecated and merged with <tt>org.eclipse.core.runtime.Platform</tt> 
  since it no longer made sense to have a split between boot and runtime. Note 
  that in fact, the org.eclipse.core.boot plug-in has been broken up and all its 
  code moved to either the new runtime or the compatibility layer. </p>
<h4>org.eclipse.core.boot.IPlatformConfiguration (class)</h4>
<p><tt>IPlatformConfiguration</tt> has always been a type defined by and for the 
  Ecliipse Install/Update component. With the reorganization of the runtime we 
  are able to repatriate this type to its rightful home. This class remains largely 
  unchanged and has been repackaged as <tt>org.eclipse.update.configurator.IPlatformConfiguration</tt>. 
  The compatibility layer retains a deprecated copy of the original class.</p>
<p></p>
<h4>org.eclipse.core.runtime.IPrerequisite (class)</h4>
<p>In the original runtime, IPrerequisite is a representation of execution related 
  attributes. In the new runtime these are now handled by OSGi. While it is possible 
  to maintain some of the API for legacy plug-ins, it is not possible to do so 
  for OSGi-based plug-ins/bundles. Users of IPrerequiste should consider using 
  Bundle.getHeader(Constants.IMPORT_PACKAGE) or Bundle.getHeader(Constants.REQUIRE_BUNDLE) 
  and processing the results using the ManifestElement helper class.</p>
<h4></h4>
<h4>org.eclipse.core.runtime.Platform (methods)</h4>
<ul>
  <li>getPlugin(String) 
    <ul>
      <li>In the new runtime, <tt>Plugin</tt> objects are no longer managed by 
        the runtime and so cannot be accessed via this method. Use &lt;XXX tentative&gt; 
        <tt>Platform.getBundle(String)</tt> instead. Note however that this returns 
        only a generic Bundle object. Those wishing to use domain-specific function 
        on a particular <tt>Plugin</tt> object must arrange for access with the 
        plug-in in question. This is typically done via a singleton pattern (e.g., 
        <tt>ResourcesPlugin.getDefault()</tt>).</li>
    </ul>
  </li>
  <li>getPluginRegistry() 
    <ul>
      <li>The plug-in registry object has been deprecated. If you are looking 
        for the registry of extensions and extension points use <tt>Platform.getExtensionRegistry()</tt>. 
        If you are looking to find the static and generic representation of a 
        plug-in, consider using &lt;XXX tentative&gt; <tt>Platform.getBundle(String)</tt>.</li>
    </ul>
  </li>
</ul>
<h4>org.eclipse.core.runtime.Plugin (methods)</h4>
<ul>
  <li>Plugin(IPluginDescriptor) 
    <ul>
      <li>The <tt>Plugin</tt> object is no longer created or managed by the runtime 
        and <tt>IPluginDescriptor</tt> is deprecated. <tt>Plugin</tt> class implementors 
        may choose to use their <tt>Plugin</tt> as a bundle activator in which 
        case they must implement (allow for) the default constructor. Users wishing 
        to have a <tt>Plugin</tt> class but not use it as the bundle activator 
        need to implement the appropriate constructor which at a minimum takes 
        the <tt>BundleContext</tt> to be associated with the plug-in.</li>
    </ul>
  </li>
  <li>getPluginDescriptor() 
    <ul>
      <li>IPluginDescriptor is now deprecated. Users of this method are looking 
        for 
        <ul>
          <li>extension/extension point information: go directly to org.eclipse.core.runtime.IExtensionRegistry</li>
          <li>manifest information: get the bundle for the plug-in (getBundle()) 
            and access its manifest headers as required.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>getPluginPreferences() 
    <ul>
      <li>&lt;xxx the preference mechanism is still in play&gt;</li>
    </ul>
  </li>
  <li>savePluginPreferences() 
    <ul>
      <li>&lt;xxx the preference mechanism is still in play&gt;</li>
    </ul>
  </li>
  <li>initializeDefaultPluginPreferences() 
    <ul>
      <li>&lt;xxx the preference mechanism is still in play&gt;</li>
    </ul>
  </li>
  <li>shutdown() and startup() 
    <ul>
      <li>These methods have been replaced with the OSGi standard <tt>start()</tt> 
        and <tt>stop()</tt> methods. Note that the new lifecycle methods are only 
        automatically called if the defining <tt>Plugin</tt> class is registered 
        as the bundle activator in a bundle manifest (MANIFEST.MF) file. See the 
        header Bundle-Activator.</li>
      <li>OSGi (and Eclipse) coding practices <b>strongly</b> recommend against 
        doing or triggering significant work in the <tt>start()</tt> methods. 
        Doing excessive work here can damage startup time as well as overall responsiveness.</li>
    </ul>
  </li>
</ul>
<h4>org.eclipse.core.runtime.IExtension<br>
  org.eclipse.core.runtime.IExtensionPoint (methods) </h4>
<ul>
  <li>getDeclaringPlugin() 
    <ul>
      <li>This method (on both classes) gives an upward link to the plug-in which 
        declares the extension or extension-point (respectively). The new registry 
        model separates the execution aspects of plug-ins from the extension/extension-point 
        aspects and no longer contains <tt>IPluginDescriptors</tt>. Users of this 
        API should consider the new method <tt>getParentIdentifier()</tt> found 
        on both <tt>IExtension</tt> and <tt>IExtensionPoint</tt>. The returned 
        value can be used directly or as a key in the compatibility <tt>IPluginRegistry</tt> 
        or the OSGi framework's API for bundle discovery (e.g., <tt>BundleContext.getBundles(String)</tt> 
        &lt;XXX point to the Platofrm method&gt;).</li>
    </ul>
  </li>
</ul>
<h4>org.eclipse.core.runtime.IPluginRegistry (class)</h4>
<p>The contents of the plug-in registry, like the runtime, has been split into 
  two parts, the execution-related and the extension-related. As such, the unified 
  notion of a plug-in registry does not apply. Uses of the IPluginRegistry to 
  discover extensions and extension-points are directly supported by nearly identical 
  API on IExtensionRegistry. Uses of IPluginRegistry to discover IPluginDescriptors 
  should be changed to use the appropriate OSGi structures. See the discussion 
  related to IPluginDescriptor for more details.</p>
<h4>org.eclipse.core.runtime.IPluginDescriptor (class)</h4>
<p>Plug-in descriptors contain methods for a number of different purposes. These 
  are outlined below as well as the steps for updating their uses.</p>
    
<dl> 
  <dl>
    <dt><b>extension-related</b> (e.g., getExtensions())</dt>
    <dd>Update such cases to use the IExtensionRegistry directly.</dd>
    <dt><b>execution-related</b> (e.g., find() and getPluginClassLoader())</dt>
    <dd>Use the related methods found on <tt>org.eclipse.core.runtime.Platform</tt></dd>
    <dt><b>accessors</b> (e.g., getLabel())</dt>
    <dd>Get the bundle associated with the descriptor and access the appropriate 
      manifest header fields.</dd>
  </dl>
</dl>
<h4>org.eclipse.core.runtime.model (package)</h4>
<p>The plug-in registry has been deprecated </p>
<p>Extension-related uses are updated by accessing the extension registry directly. 
</p>
<h4>org.eclipse.core.boot.IPlatformRunnable (class)</h4>
&lt;XXX tentative&gt; This class has been deprecated in favour of the identical 
class org.eclipse.core.runtime.IPlatformRunnable. 
<h3>Updating plugin.xml, fragment.xml and plugin.properties</h3>
<p>The new runtime is based on an implementation of the OSGi framework specification. 
  The OSGi specification mandates the use of MANIFEST.MF files to define the execution 
  of a plug-in. This conflicts with the Eclipse notion of plugin.xml as far as 
  &lt;runtime&gt; and &lt;requires&gt; elements are concerned. The easiest way 
  to update your plugin.xml or fragment.xml is to use the PDE Migration Tool (PDE 
  Tools-&gt;Convert to OSGi bundle).</p>
<p>This tool will split your plugin.xml into two files, META-INF/MANIFEST.MF and 
  eclipse.xml. The manifest is a standard Java Jar file manifest. It contains 
  specifications for the execution elements of our plug-in (e.g., classpath, prerequisites, 
  ...). A table of frequent mapping is included below while the full <a href="http://www.osgi.org">OSGi 
  specification</a> has enumerates all pre-defined manifest headers.</p>
<table width="100%" border="1">
  <tr> 
    <td>
      <div align="center"><b>plugin.xml tag/attribute</b></div>
    </td>
    <td>
      <div align="center"><b>manifest.mf header</b></div>
    </td>
  </tr>
  <tr> 
    <td>&lt;plugin id&gt;</td>
    <td>Bundle-GlobalName</td>
  </tr>
  <tr> 
    <td>&lt;plugin version&gt;</td>
    <td>Bundle-Version</td>
  </tr>
  <tr> 
    <td>&lt;plugin name&gt;</td>
    <td>Bundle-Name</td>
  </tr>
  <tr> 
    <td>&lt;plugin provider&gt;</td>
    <td>Bundle-Vendor</td>
  </tr>
  <tr> 
    <td>&lt;plugin class&gt;</td>
    <td>Bundle-Activator</td>
  </tr>
  <tr> 
    <td>&lt;requires&gt;, &lt;import&gt;</td>
    <td>Require-Bundle</td>
  </tr>
  <tr> 
    <td>&lt;runtime&gt;, &lt;library&gt;</td>
    <td>Bundle-ClassPath</td>
  </tr>
</table>
<p>The extension/extension-point related information in the plugin.xml moves directly 
  and unchanged into the eclipse.xml file. The top level tag of this file is <tt>&lt;eclipse&gt;</tt> 
  and there are no attributes defined at this point.</p>
<p>In a related move, the plugin.properties file is deprecated and has been renamed 
  to <tt>eclipse.properties</tt>. It continues to supply translations for both 
  the execution information in the manifest file and the extension information 
  in eclipse.xml.</p>
<p>The build.properties file remains unchanged.</p>
<table border=0 cellspacing=0 cellpadding=2 width="100%" >
  <tr> 
    <td align=LEFT valign=TOP colspan="2" bgcolor="#0080C0"><b><font color="#FFFFFF"> 
      Feedback</font></b></td>
  </tr>
</table>
<p> Should you encounter any problems while using the Equinox runtime, you are 
  encouraged to either log a bug report in the <a href="https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Equinox">Equinox 
  Bugzilla database</a> or make a posting to the Core <a href="http://dev.eclipse.org/mailman/listinfo/platform-core-dev">mailing 
  list</a> or the Platform <a href="news://news.eclipse.org/eclipse.platform">newsgroup</a>. 
</p>
</body>
</html>
