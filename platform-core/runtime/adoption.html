<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=charset=ISO-8859-1">
  <title>Eclipse 3.0 Runtime Adoption Guide</title>
  <link rel="stylesheet" href="/default_style.css">
</head>
  <body link="#0000ff" vlink="#800080">
       
<p align="right"><img src="file:///D|/equinox/ngibmcpy.gif" alt="Copyright IBM Corporation and others 2000, 2003." border="0" width="324" height="14"></p>
<table border="0" cellspacing="0" cellpadding="2" width="100%">
      <tbody>
        <tr>
          <td align="Left" valign="Top" colspan="2" bgcolor="#0080c0"><b><font face="Arial,Helvetica"><font color="#ffffff">
 Eclipse Corner Article</font></font></b></td>
        </tr>
  </tbody>    
</table>

<div align="Left">    
  <h1><img src="file:///D|/equinox/prototype/plugins/images/Idea.jpg" height="86" width="120" align="Center">
  </h1>
</div>

<h1 align="Center">Eclipse 3.0 Runtime Adoption Guide</h1>
<blockquote>            
  <p><b>Summary</b><br>
    <center>
      <b>This is a draft document. </b> 
    </center>
    <br>
    This document details the steps required to <b>adopt</b> the new mechanisms 
    found in the Eclipse 3.0 runtime. In most cases, plug-in developers do not 
    need to follow these steps as the 3.0 runtime supports the 2.1-style API. 
    However, the new runtime offers significant new <i>experimental</i> function. 
    It is this function which is detailed here. </p>
  <p><b> By Jeff McAffer, IBM OTI Labs</b><br>
    <font size="-1">February 24, 2004</font></p>
</blockquote>
<hr width="100%">

<h2>Preamble</h2>
<p>In this document the terms <i>deprecated</i> and <i>obsolete</i> are used to 
  mean that the code is not part of the Eclipse runtime story going forward. For 
  Eclipse 3.0 this code is still a full-fledged member of the API and is fully 
  supported. </p>
<h4></h4>
<p>The new runtime is 99% binary compatible with the original Eclipse runtime. 
  That is, with the exception of the cases listed above, <b>most existing plug-ins 
  will continue to run unchanged.</b> </p>
<p>Having said that, there are costs associated with the compatibilty layer and 
  the full power of the new runtime is not available to legacy plug-ins. Plug-in 
  developers interested in additional performance and function should consider 
  adopting the new APIs and removing their dependence on the compatibility layer. 
  Compatibility code shows up in three places:</p>
<ul>
  <li>org.eclipse.core.boot - entire plug-in are legacy</li>
  <li>org.eclipse.core.runtime.compatibility - entire plug-in are legacy</li>
  <li>org.eclipse.core.runtime - various classes and methods are legacy</li>
</ul>
<p>The text below gives more detail on the which classes and methods are present 
  for compatibility purposes as well as guidance on how to update your plug-in 
  should you choose to.</p>
<h3>Plug-ins and bundles</h3>
<p>The Eclipse runtime has been refactored into two parts; classloading and prerequisite 
  management, and extension/extension-point management. This split allows for 
  natural/seamless adoption of the OSGi framework specification for classloading 
  and prerequisite management. This in turn enables a range of new capabilities 
  in the runtime from dynamic plug-in install/update/uninstall to security and 
  increased configurability.</p>
<p>While we continue to talk about <i>plug-ins</i>, in the new runtime a plug-in 
  is really a <i>bundle</i> plus some extensions and extension-points. The term 
  <i>bundle</i> is defined by the OSGi framework specification and refers to a 
  collection of types and resources and associated inter-bundle prerequisite information. 
  The <i>extension registry</i> (and related types) is the new form of the plug-in 
  registry (and related types) and details only extension and extension-point 
  information. By-in-large the extension registry API is the same as the relevant 
  plug-in registry API (for more information see <a href="#registries">Registries</a>).</p>
<p>In the Eclipse 2.x runtime, the plug-in object has a number of roles and responsibilities:</p>
<ul>
  <li>Lifecycle - The <tt>Plugin</tt> class implements method such as startup() 
    and shutdown(). The runtime uses these methods to signal the plug-in that 
    someone is interested in the function it provides. In response, plug-ins typically 
    do a combination of: 
    <ul>
      <li>Registration - Hook various event mechanisms (e.g., register listeners) 
        and otherwise make their presence known in the system (e.g., start needed 
        threads). </li>
      <li>Initialization - Initialize or prime their data structures and load 
        models so they are ready for use.</li>
    </ul>
  </li>
  <li>Plug-in global data/function - While never explicitly put forth for this 
    role, in common practice plug-in classes have become a place to hang data 
    and function which is effectively global to the plug-in itself. In some cases 
    this data/function is API in others it is internal. For example, the UI plug-in 
    exposes as API methods such as <tt>getDialogSettings()</tt> and <tt>getWorkbench()</tt>.</li>
  <li>Context - The standard <tt>Plugin</tt> class provides access to various 
    runtime-provided function such as preferences and logging.</li>
</ul>
<p>In the Eclipse 3.0 runtime picture, these roles and responsibilities are factored 
  into distinct objects.</p>
<dl> 
  <dl> 
    <dt><b>Bundle</b></dt>
    <dd>Bundles are the OSGi unit of modularity. There is one classloader per 
      bundle and Eclipse-like inter-bundle class loading dependency graphs can 
      be constructed. Bundles have lifecycle for start and stop and the OSGi framework 
      broadcasts bundle related events (e.g., install, resolve, start, stop, uninstall, 
      ...) to interested parties. Unlike the Eclipse <tt>Plugin</tt> class, the 
      OSGi <tt>Bundle</tt> class is not extensible. That is, developers do not 
      have the opportunity to define their own bundle class.</dd>
    <dt><b>BundleActivator</b></dt>
    <dd>BundleActivator is an interface defined by the OSGi framework. Each bundle 
      can define a bundle activator class much like a plug-in can define its <tt>Plugin</tt> 
      class. This class is instantiated by the framework and used to implement 
      the <tt>start()</tt> and <tt>stop()</tt> lifecycle processing. There is 
      a major difference however in the nature of this lifecycle processing. In 
      Eclipse it is common (though not recommended) to have the <tt>Plugin</tt> 
      classes do both initialization and registration. In OSGi activators must 
      only do registration. Doing large amounts of initialization (or any other 
      work) in <tt>BundleActivator.start()</tt> threatens the liveness of the 
      system.</dd>
    <dt><b>BundleContext</b></dt>
    <dd>BundleContexts are the OSGi mechanism for exposing general system function 
      to individual bundles. Each bundle has a unique and private instance of 
      BundleContext which they can use to access system function (e.g., getBundles() 
      to discover all bundles in the system).</dd>
    <dt><b>Plugin</b></dt>
    <dd>The new <tt>Plugin</tt> is very much like the original Eclipse <tt>Plugin</tt> 
      class with the following exceptions: <tt>Plugin</tt> objects are no longer 
      a) required or b) managed by the runtime and various methods have been deprecated 
      (see below). As such, Plugin continues to provide context access. It is 
      essentially a convenience mechanism providing a host of useful function 
      and mechanisms but is no longer absolutely required. Much of the function 
      provided there is also available on the <tt>Platform</tt> class in the runtime. 
      <p><tt>Plugin</tt> also implements <tt>BundleActivator</tt>. This recognizes 
        the convenience of having one central object representing the lifecycle 
        and semantic of a plug-in. Note that this does not however sanction the 
        eager initialization of data structures that is common in plug-ins today. 
        We cannot stress enough that plug-ins can be activated because a somewhat 
        peripheral class was referenced during verification of a class in some 
        other plug-in. That is, just because your plug-in has been activated does 
        not necessarily mean that its function is needed. Note also that you are 
        free to define a different <tt>BundleActivator</tt> class or not have 
        a bundle activator at all.</p>
    </dd>
  </dl>
</dl>
<p>The steps required to port a 2.x <tt>Plugin</tt> class to Eclipse 3.0 depends 
  on what the class is doing. As outlined above, most startup lifecycle work falls 
  into one of the following categories:</p>
<dl> 
  <dl> 
    <dt><b>Initialization</b></dt>
    <dd>Datastructure and model initialization is quite often done in <tt>Plugin.startup()</tt>. 
      The natural/obvious mapping would be to do this work in a <tt>BundleActivator.start()</tt>, 
      that is to leave the function on <tt>Plugin</tt>. <b> This is strongly discouraged.</b> 
      As with 2.x plug-ins, 3.0 plug-ins/bundles may be started for many different 
      reasons in many different circumstances. <br>
      An actual example from Eclipse 2.0 days illuminates this case. There was 
      a plug-in which initialized a large model requiring the loading of some 
      11MB of <i>code</i> and many megabytes of data. There were quite common 
      usecases where this plug-in was activated to discover if the project icon 
      presented in the navigator should be decorated with a particular markup. 
      This test did not require any of the initialization done in <tt>startup()</tt> 
      but yet all users, in all usecases had to pay the memory and time penalty 
      for this eager initialization.<br>
      The alternative approach is to do such initialization in a classic lazy 
      style. For example, rather than having models initialized when the plug-in/bundle 
      is activated, do it when they are actually needed (e.g., in a centralized 
      model accessor method). For many usecases this will amount to nearly the 
      same point in time but for other scenarios this approach will defer initialization 
      (perhaps indefinitely). We recommend taking time while porting 2.1 plug-ins 
      to reconsider the initialization strategy used. </dd>
    <dt><b>Registration</b></dt>
    <dd>Plug-in startup is a convenient time to register listeners, services etc. 
      and start background processing threads (e.g., listening on a socket). <tt>Plugin.start()</tt> 
      may a reasonable place to do this work. It may also make sense to defer 
      until some other trigger (e.g., the use of a particular function or data 
      element).</dd>
    <dt><b>Plug-in global data</b></dt>
    <dd>Your <tt>Plugin</tt> class can continue to play this role. The main issue 
      is that <tt>Plugin</tt> objects are no longer globally accessible via a 
      system-managed list. In Eclipse 2.x you could discover any plug-in's <tt>Plugin</tt> 
      ojbect via the plug-in registry. This is no longer possible. In most circumstances 
      this type of access is not required. <tt>Plugins</tt> accessed via the registry 
      are more typically used as generic <tt>Plugins</tt> rather than calling 
      domain-specific methods.</dd>
  </dl>
</dl>
<h3><a name="registries"></a>Registries and the plug-in model</h3>
<p>In the new runtime there is a separation between the information and structures 
  needed to execute a plug-in and that related to a plug-in's extensions and extension 
  points. The former is defined and managed by the OSGi framework specification. 
  The latter are Eclipse-specific concepts and are added by they Eclipse runtime 
  code. Accordingly, the original plug-in registy and related objects have been 
  split into OSGi <i>bundles</i> and the Eclipse <i>extension registry</i>. </p>
<p>The parts of <tt>IPluginRegistry</tt> dealing with execution specification 
  (e.g., <tt>IPluginDescriptor, ILibrary</tt>, <tt>IPrequisite</tt>) have been 
  deprecated and the remaining parts related to extensions and extension point 
  have been moved to <tt>IExtensionRegistry</tt>. Further, the so-called model 
  objects related to the plug-in registry as a whole are now deprecated. These 
  types were presented and instantiated by the runtime primarily to support tooling 
  such as PDE. Unfortunately, it was frequently the case that the level of information 
  needed exceeded the runtime's capabilities or interests (e.g., remembering line 
  numbers for plugin.xml elements) and in the end, the potential consumers of 
  the runtime's information had to maintain their own structures anyway.</p>
<p>In the new runtime we have re-evaluated the facilities provided by the runtime 
  and now provide only those which are either essential for runtime execution 
  or are extraordinarily difficult for others to do. As mentioned above, the plug-in 
  registry model objects have been deprecated as has the plug-in parsing API. 
  The new extensions registry maintains the essential extension-related information. 
  A new <i>state</i> (see <tt>org.eclipse.osgi.service.resolver.State</tt> and 
  friends) structure represents and allows the manipulation of the essential execution-related 
  information. </p>
<h3></h3>
<h3>Legacy code</h3>
<h4>org.eclipse.core.boot.BootLoader (class)</h4>
<p>BootLoader has been completely deprecated and merged with <tt>org.eclipse.core.runtime.Platform</tt> 
  since it no longer made sense to have a split between boot and runtime. Note 
  that in fact, the org.eclipse.core.boot plug-in has been broken up and all its 
  code moved to either the new runtime or the compatibility layer. </p>
<h4>org.eclipse.core.boot.IPlatformConfiguration (class)</h4>
<p><tt>IPlatformConfiguration</tt> has always been a type defined by and for the 
  Ecliipse Install/Update component. With the reorganization of the runtime we 
  are able to repatriate this type to its rightful home. This class remains largely 
  unchanged and has been repackaged as <tt>org.eclipse.update.configurator.IPlatformConfiguration</tt>. 
  The compatibility layer retains a deprecated copy of the original class.</p>
<p></p>
<h4>org.eclipse.core.boot.IPlatformRunnable (class)</h4>
This class has been deprecated in favour of the identical class org.eclipse.core.runtime.IPlatformRunnable. 
The was the last remaining use of &quot;boot&quot; in the API and was confusing 
for people. 
<h3></h3>
<h4>org.eclipse.core.runtime.IExtension<br>
  org.eclipse.core.runtime.IExtensionPoint (methods) </h4>
<ul>
  <li>getDeclaringPlugin() 
    <ul>
      <li>This method (on both classes) gives an upward link to the plug-in which 
        declares the extension or extension-point (respectively). The new registry 
        model separates the execution aspects of plug-ins from the extension/extension-point 
        aspects and no longer contains <tt>IPluginDescriptors</tt>. Users of this 
        API should consider the new method <tt>getParentIdentifier()</tt> found 
        on both <tt>IExtension</tt> and <tt>IExtensionPoint</tt>. The returned 
        value can be used directly or as a key in the compatibility <tt>IPluginRegistry</tt> 
        or the OSGi framework's API for bundle discovery (e.g., <tt>BundleContext.getBundles(String)</tt> 
        &lt;XXX point to the Platofrm method&gt;).</li>
    </ul>
  </li>
</ul>
<h4></h4>
<h4>org.eclipse.core.runtime.ILibrary (class)</h4>
<p> In the original runtime, ILibrary is a representation of execution related 
  attributes. In the new runtime these are now handled by OSGi. While it is possible 
  to maintain some of the API for legacy plug-ins, it is not possible to do so 
  for OSGi-based plug-ins/bundles. Users of ILibrary should consider using Bundle.getHeader(Constants.BUNDLE_CLASSPATH) 
  and processing the results using the ManifestElement helper class.</p>
<h4></h4>
<h4>org.eclipse.core.runtime.IPrerequisite (class)</h4>
<p>In the original runtime, IPrerequisite is a representation of execution related 
  attributes. In the new runtime these are now handled by OSGi. While it is possible 
  to maintain some of the API for legacy plug-ins, it is not possible to do so 
  for OSGi-based plug-ins/bundles. Users of IPrerequiste should consider using 
  Bundle.getHeader(Constants.IMPORT_PACKAGE) or Bundle.getHeader(Constants.REQUIRE_BUNDLE) 
  and processing the results using the ManifestElement helper class.</p>
<h4></h4>
<h4>org.eclipse.core.runtime.Platform (methods)</h4>
<ul>
  <li>getPlugin(String) 
    <ul>
      <li>In the new runtime, <tt>Plugin</tt> objects are no longer managed by 
        the runtime and so cannot be accessed via this method. Use &lt;XXX tentative&gt; 
        <tt>Platform.getBundle(String)</tt> instead. Note however that this returns 
        only a generic Bundle object. Those wishing to use domain-specific function 
        on a particular <tt>Plugin</tt> object must arrange for access with the 
        plug-in in question. This is typically done via a singleton pattern (e.g., 
        <tt>ResourcesPlugin.getDefault()</tt>).</li>
    </ul>
  </li>
  <li>getPluginRegistry() 
    <ul>
      <li>The plug-in registry object has been deprecated. If you are looking 
        for the registry of extensions and extension points use <tt>Platform.getExtensionRegistry()</tt>. 
        If you are looking to find the static and generic representation of a 
        plug-in, consider using &lt;XXX tentative&gt; <tt>Platform.getBundle(String)</tt>.</li>
    </ul>
  </li>
</ul>
<h4>org.eclipse.core.runtime.Plugin (methods)</h4>
<ul>
  <li>Plugin(IPluginDescriptor) 
    <ul>
      <li>The <tt>Plugin</tt> object is no longer created or managed by the runtime 
        and <tt>IPluginDescriptor</tt> is deprecated. <tt>Plugin</tt> class implementors 
        may choose to use their <tt>Plugin</tt> as a bundle activator in which 
        case they must implement (allow for) the default constructor. Users wishing 
        to have a <tt>Plugin</tt> class but not use it as the bundle activator 
        need to implement the appropriate constructor which at a minimum takes 
        the <tt>BundleContext</tt> to be associated with the plug-in.</li>
    </ul>
  </li>
  <li>getPluginDescriptor() 
    <ul>
      <li>IPluginDescriptor is now deprecated. Users of this method are looking 
        for 
        <ul>
          <li>extension/extension point information: go directly to org.eclipse.core.runtime.IExtensionRegistry</li>
          <li>manifest information: get the bundle for the plug-in (getBundle()) 
            and access its manifest headers as required.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>getPluginPreferences() 
    <ul>
      <li>&lt;xxx the preference mechanism is still in play&gt;</li>
    </ul>
  </li>
  <li>savePluginPreferences() 
    <ul>
      <li>&lt;xxx the preference mechanism is still in play&gt;</li>
    </ul>
  </li>
  <li>initializeDefaultPluginPreferences() 
    <ul>
      <li>&lt;xxx the preference mechanism is still in play&gt;</li>
    </ul>
  </li>
  <li>shutdown() and startup() 
    <ul>
      <li>These methods have been replaced with the OSGi standard <tt>start()</tt> 
        and <tt>stop()</tt> methods. Note that the new lifecycle methods are only 
        automatically called if the defining <tt>Plugin</tt> class is registered 
        as the bundle activator in a bundle manifest (MANIFEST.MF) file. See the 
        header Bundle-Activator.</li>
      <li>OSGi (and Eclipse) coding practices <b>strongly</b> recommend against 
        doing or triggering significant work in the <tt>start()</tt> methods. 
        Doing excessive work here can damage startup time as well as overall responsiveness.</li>
    </ul>
  </li>
</ul>
<h4>org.eclipse.core.runtime.IPluginDescriptor (class)</h4>
<p>Plug-in descriptors contain methods for a number of different purposes. These 
  are outlined below as well as the steps for updating their uses.</p>
<dl> 
  <dl> 
    <dt><b>extension-related</b> (e.g., getExtensions())</dt>
    <dd>Update such cases to use the IExtensionRegistry directly.</dd>
    <dt><b>execution-related</b> (e.g., find() and getPluginClassLoader())</dt>
    <dd>Use the related methods found on <tt>org.eclipse.core.runtime.Platform</tt></dd>
    <dt><b>accessors</b> (e.g., getLabel())</dt>
    <dd>Get the bundle associated with the descriptor and access the appropriate 
      manifest header fields.</dd>
  </dl>
</dl>
<h4></h4>
<h4>org.eclipse.core.runtime.IPluginRegistry (class)</h4>
<p>The contents of the plug-in registry, like the runtime, has been split into 
  two parts, the execution-related and the extension-related. As such, the unified 
  notion of a plug-in registry does not apply. Uses of the IPluginRegistry to 
  discover extensions and extension-points are directly supported by nearly identical 
  API on IExtensionRegistry. Uses of IPluginRegistry to discover IPluginDescriptors 
  should be changed to use the appropriate OSGi structures. See the discussion 
  related to IPluginDescriptor for more details.</p>
<h4>org.eclipse.core.runtime.model (package)</h4>
<p>All types in this package are now deprecated. See the discussion on <a href="#registries">registries</a> 
  for more information.</p>
<h3>Updating plugin/fragment files</h3>
<p>The new runtime is based on an implementation of the OSGi framework specification. 
  The OSGi specification mandates the use of MANIFEST.MF files to define the execution 
  of a plug-in. This conflicts with the Eclipse notion of plugin.xml as far as 
  &lt;runtime&gt; and &lt;requires&gt; elements are concerned. The easiest way 
  to update your plugin.xml or fragment.xml is to use the PDE Migration Tool (PDE 
  Tools-&gt;Convert to OSGi bundle).</p>
<p>In certain situations the conversion tool is unable to correctly determine 
  all of the packages provided by a plug-in. In particular, if a plug-in declares 
  a library entry for say foo.jar but does not contain foo.jar, the converter 
  is unable to generate the appropriate provides-package entries in the output 
  manifest (this is done by analyzing the supplied jar which, in this case, is 
  not present). Plug-in or fragments which are fully self-contained are converted 
  correctly. </p>
<p>This tool extracts the execution-specific information from your plugin.xml 
  and puts into the OSGi mandated META-INF/MANIFEST.MF file. All extension-related 
  information is left in the plugin.xml. The manifest is a standard Java Jar file 
  manifest. It contains specifications for the execution elements of our plug-in 
  (e.g., classpath, prerequisites, ...). A table of frequent mapping is included 
  below while the full <a href="http://www.osgi.org">OSGi specification</a> has 
  enumerates all pre-defined manifest headers.</p>
<table width="100%" border="1">
  <tr> 
    <td> 
      <div align="center"><b>plugin.xml tag/attribute</b></div>
    </td>
    <td> 
      <div align="center"><b>manifest.mf header</b></div>
    </td>
  </tr>
  <tr> 
    <td>&lt;plugin id=&gt;</td>
    <td>Bundle-SymbolicName</td>
  </tr>
  <tr> 
    <td>&lt;plugin version=&gt;</td>
    <td>Bundle-Version</td>
  </tr>
  <tr> 
    <td>&lt;plugin name=&gt;</td>
    <td>Bundle-Name</td>
  </tr>
  <tr> 
    <td>&lt;plugin provider=&gt;</td>
    <td>Bundle-Vendor</td>
  </tr>
  <tr> 
    <td>&lt;plugin class=&gt;</td>
    <td>Bundle-Activator</td>
  </tr>
  <tr>
    <td>&lt;fragment plugin-id=&gt;</td>
    <td>Fragment-Host</td>
  </tr>
  <tr>
    <td>&lt;fragment plugin-version=&gt;</td>
    <td>Fragment-Host: &lt;id&gt;; bundle-version=</td>
  </tr>
  <tr> 
    <td>&lt;requires&gt;, &lt;import&gt;</td>
    <td>Require-Bundle</td>
  </tr>
  <tr> 
    <td>&lt;runtime&gt;, &lt;library&gt;</td>
    <td>Bundle-ClassPath</td>
  </tr>
</table>
<p>The extension/extension-point related information continues to be detailed 
  in the plugin.xml file however the following aspects of the plugin.xml DTD are 
  being deprecated.</p>
<ul>
  <li>all attributes on the &lt;plugin&gt; tag</li>
  <li>&lt;runtime&gt; and its &lt;library&gt; subelement</li>
  <li>&lt;requires&gt; and its &lt;import&gt; subelement</li>
</ul>
<p>This leaves the plugin.xml containing only the &lt;plugin&gt;, &lt;extension&gt; 
  and &lt;extension-point&gt; tags</p>
<p>Note also that the form of this content is not specific to a plug-ins vs. fragments. 
  As a result, the fragment.xml file is being deprecated and renamed to plugin.xml 
  with the outlined DTD changes. In most cases fragments do not supply extensions 
  or extension-points so the bulk of the change required is done while moving 
  to the MANIFEST.MF file and the fragment.xml file can be deleted.</p>
<p>The <tt>plugin.properties</tt> file continues to supply translations for the 
  extension/extension-point information in plugin.xml and also supplies translations 
  for various keys in the MANIFEST.MF.</p>
<p>The build.properties file remains unchanged.</p>
<h3>NL fragment structure</h3>
<p>In Eclipse 3.0 the NL fragment structure has been updated to be more consistent.
  Previously the translations for files like plugin.properties were assumed to
  be inside of JARs supplied by fragments. Since the original files are found
  in the root of the relevant host plug-in, a more consistent location would
  have the translated files located in the root of the NL fragments. For example, </p>
<pre><font color="#4444CC">  org.eclipse.ui.workbench.nl/
     fragment.xml
     plugin_fr.properties
     plugin_pt_BR.properties
     ...
     nl1.jar</font></pre>
Note here that the file nl1.jar previously would have contained the translations
for plugin.properties. These files are now at the root of the fragment and the
JAR contains translations of any translatable resources (i.e., files loaded via
the classloader) in the host plug-in.
  </body>
</html>
