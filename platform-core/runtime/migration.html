<html>
<head>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<title>The Equinox Project - Migration Guide</title>
		<link rel="stylesheet" title="default" href="http://eclipse.org/default_style.css" type="text/css">
		<style>
			th,td { vertical-align:top; text-align=left}
			.issue { font-style:oblique; width:200px;}
			.box	{ background-color:#E0E0FF}
		</style>
	</head>
	<body>
		<table BORDER=0 CELLSPACING=5 CELLPADDING=2 WIDTH="100%" >
			<tr> 
				<td ALIGN=left width="60%">
					<p><font class=indextop> equinox</font><br>
        <font class=indexsub> migration guide</font> </p>
				</td>
				<td WIDTH="40%">&nbsp; </td>
			</tr>
		</table>

<blockquote> 
  <p><b>Summary</b> <br>
    This document details the API changes between the standard Eclipse runtime 
    (e.g., Eclipse 3.0 M5) to the OSGi-based runtime developed in the Equinox 
    project (e.g., Eclipse 3.0 M6). Information on migrating workspaces, code 
    and general workspace setup can be found in the <a href="adoption.html">Adoption 
    Guide</a> and information on how to use the new runtime is contained in the 
    <a href="howto.html">Users Guide</a>.<br>
    Last Modified: 2300 November 25, 2003</p>
</blockquote>
<table border=0 cellspacing=0 cellpadding=2 width="100%" >
  <tr> 
    <td align=LEFT valign=TOP colspan="2" bgcolor="#0080C0"><b><font color="#FFFFFF"> 
      API Changes</font></b></td>
  </tr>
</table>
<p> For each of the API changes listed below, there is a corresponding Bugzilla 
  bug report number. Readers are encouraged to comment on or track these bug reports 
  as a way of providing feedback into the Eclipse runtime design and implementation 
  process. All migration related bug reports have [migration] prepended to the 
  summary line. Users can query Bugzilla to get up to date information on new 
  issues as well as status on old/resolved issues.</p>
      
<h3>URL Stream Handler extensions (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=43400">43400</a>)</h3>
<p><b>Who is affected:</b> Plug-ins which contribute extensions to the <tt>org.eclipse.core.runtime.urlHandlers</tt> 
  extension point.</p>
<p><b>Description:</b> OSGi provides a URL Stream Handler service much like that 
  supported by Eclipse runtime. This allows people to register URL stream handlers 
  for different URL protocols (e.g., jndi: URLs). Because of various design issues 
  with the base Java URL handler mechanism, URLStreamHandlers registered with 
  the OSGi handler service must implement <tt>org.osgi.service.url.URLStreamHandlerService</tt>. 
  The OSGi framework provides a handy abstract superclass (<tt>org.osgi.service.url.AbstractURLStreamHandlerService</tt>) 
  that does the bulk of this work. </p>
<p>Unfortunately, legacy plug-ins which supply URL handler contributions (extensions 
  to the <tt>org.eclipse.core.runtime.urlHandlers</tt> extension point) implement 
  only the java.net.URLStreamHandler contract. Since all of the methods on URLStreamHandler 
  are protected, it is not possible for the runtime compatibility layer to simply 
  wrap such handlers to and give them the required behaviour. Rather, the implementation 
  of the handler must be updated either to implement <tt>org.osgi.service.url.URLStreamHandlerService</tt> 
  or to extend <tt>org.osgi.service.url.AbstractURLStreamHandlerService</tt>.</p>
<p><b>Analysis:</b> Very few plug-ins use this facility. A quick scan of major 
  Eclipse-based products (e.g., WSAD) failed to uncover any uses. Eclipse itself 
  uses this capability in the Help area (e.g., for help: and jndi: URLs). This 
  has usage has been updated as described above. </p>
<p><b>Technical notes:</b> We continue to look for ways of wrappering supplied 
  URLStreamHandlers and thus supplying full compatibility support. Failing this, 
  the minor code changes described here are required.<br>
</p>
<h3>Classload order (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=43401">43401</a>)</h3>
<p><b>Who is affected:</b> Plug-ins which supply packages provided which are also 
  supplied by other plug-ins.</p>
<p><b>Description:</b> In standard Eclipse, classloader search for classes using 
  the so-called PSP ordering. That is, a given classloader would first consult 
  its <b>p</b>arent classloader (in practice this is the Java boot classloader), 
  then its own classpath contents (i.e., <b>s</b>elf) and finally all of its <b>p</b>rerequisites 
  in declared order. OSGi offers an optimization over this model, the so-called 
  P-P|S (read P, P or S) ordering. In this approach a classloader will consult 
  its parent (again, effectively the Java boot classloader), then either a single 
  prerequisite known to contribute classes in the package being queried <b>OR</b> 
  its own classpath entries for the desired class.</p>
<p>The classloader determines whether to consult self or its prerequisites based 
  on its imported packages. This information is inferred from the plug-in content 
  in the case of legacy plug-ins and directly specified in the case of new plug-ins. 
  In either case, it is known a priori which classloaders will supply the classes 
  for which packages. This offers performance improvements as well as a solution 
  to the vexing problem of multiple prerequisites contributing the same classes.</p>
<p>Take for example the case of Xerces and Xalan. Both contain various classes 
  from org.xml packages. Under the PSP model, the Xerces plug-in would see its 
  copy of these classes while the Xalan plug-in would see their copy. Since these 
  plug-ins need to communicate, ClassCastExceptions occur. Under the P-P|S model, 
  only one of the two plug-ins contributes the duplicate classes and both plug-ins 
  see the same copies.</p>
<p><b>Analysis:</b> In a very limited number of cases the new behaviour will change 
  which classes are found. Note however that this may actually be beneficial (see 
  above).</p>
<h3>Support for multiple plug-in versions (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=43402">43402</a>)</h3>
<p><b>Who is affected:</b> System integrators/product developers expecting to 
  configure overlapping sets of plug-ins with different version numbers into one 
  Eclipse install.</p>
<p><b>Description: </b>Eclipse allows multiple versions of the same plug-in to 
  co-exist. Since OSGi resolves package imports/exports to one version it does 
  not support multiple plug-in versions. There are two proposals for adding multiversion 
  support to the OSGi framework. Both are feasible but differ in how version differences 
  are propogated. </p>
<p><b>Analysis:</b> This usecase is real and the lack of support is temporary. 
  The Equinox team is busily working on this issue and hope to resolve it shortly.</p>
<h2></h2>
<h3>Package duplication (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=43403">43403</a>)</h3>
<p><b>Who is affected:</b> Plug-ins which <i>export</i> whole packages which are 
  also exported by other plug-ins.</p>
<p><b>Description: </b>Eclipse allows multiple copies of the same package to co-exist 
  (in different plug-ins). Since OSGi resolves package imports/exports to one version 
  it does not support multiple package copies. </p>
<p><b>Analysis:</b> This usecase is real and the lack of support is temporary. 
  A solution to this issue is currently being implemented by the Equinox team.</p>
<h3>Default package content cannot be shared</h3>
<p><b>Who is affected:</b> Plug-ins which expect to use types or resources in the 
  default package of another plug-in</p>
<p><b>Description:</b> In OSGi the only way for one bundle to access the code 
  or resources from another bundle is if the latter exports the package containing 
  the target code or resources. It is not possible to export the default package 
  as all bundles have the default package and the runtime would choose just one 
  under the normal package resolutions rules. In the Eclipse runtime this is not 
  a problem since code/resource sharing was available at the whole plug-in level 
  (i.e., everything in a plug-in could be made available to dependents).</p>
<p><b>Analysis:</b> The incidence of default package use is very low so the affects 
  are not widespread. For example, we have seen this in test suites where the 
  test bundles try to access files from the test target using getResource() and 
  the required file happens to be in the root of a jar on the classpath. </p>
<p>Plug-in developers can address this by moving such files but moving them to, 
  say icons/ in the jar (rather than the root) does not help because the package 
  &quot;icons&quot; would have to be exported and would surely conflict with some 
  other bundle doing the same. The best approach is to either put the files in 
  a real, unique, package or remove such files from the classpath and access them 
  via the Bundle.getFileEntry() API.</p>
<p><b>Technical notes:</b> This issue could be addressed in backwards compatible 
  way as part of the bundle as module work. If the dependent bundle imports the 
  prerequisite bundle (rather than specific packages), it should have access to 
  the prerequisite's entire list of provided packages. This list would include 
  the default package.</p>
<h3>PluginModel object casting (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=43404">43404</a>)</h3>
<p></p>
<p><b>Who is affected:</b> Plug-ins which cast objects of type IPlugin* to Plugin*Model.</p>
<p><b>Description:</b> The Eclipse API provides a series of interfaces (e.g., 
  <tt>IPluginDescriptor</tt>) and so-called &quot;model&quot; classes (e.g., <tt>PluginDescriptorModel</tt>) 
  related to plug-ins and the plug-in registry. In the implementation it happens 
  that the model classes implement the relevant interfaces. In the runtime we 
  are unable to maintain this relationship.</p>
<p><b>Analysis:</b> The relationship between the interfaces and the model classes 
  is not a specified part of the API. We have found however that PDE takes advantage 
  of this assumption. We do not expect there to be many (any) other uses of this 
  relationship and the PDE code is quite easily changed. </p>
<h3>Invalid assumptions regarding the form of URLs (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=43658">43406</a>)</h3>
<p><b>Who is affected:</b> Plug-ins which make assumptions regarding their installation 
  structure, location and the local file system layout.</p>
<p><b>Description:</b> Methods such as <tt>IPluginDescriptor.getInstallURL()</tt> 
  return URLs of a particular form. Despite this form not being specified, various 
  plug-ins make assumptions based on the current implementation. For example, 
  they may expect to get a file: URL and use <tt>URL.getFile()</tt> and use java.io.File 
  manipulation on the result. To date, this has been a workable but rather unsafe 
  approach. For example, if a plug-in is installed on a web server, it is possible 
  that an http: URL would be returned. The OSGi runtime opens more possibilities 
  for execution configurations (e.g., maintaining whole plugins in JARs rather 
  than exploded in directories). </p>
<p><b>Analysis:</b> The new runtime does not actually break current behaviour 
  but as described above, it exposes more cases where current assumptions are 
  invalid. Plug-in writers should ensure that the information to which they need 
  access is available via <tt>getResource()</tt>, use the relevant API for accessing 
  the contents of a bundle/plug-in.</p>
<h3>Plug-ins hosting classpath entries for fragments (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=43406">43658</a>)</h3>
<p><b>Who is affected:</b> Plug-ins which declare classpath entries in their plugin.xml 
  file but where the actual jars are intended to be supplied by fragments to the 
  plug-in and fragments which expect to see package visible code in their host. 
</p>
<p><b>Description:</b> Standard Eclipse manages fragments by seamlessly merging 
  the entries in their fragment.xml files with those of the host plug-in's plugin.xml 
  file. For example, at runtime only the host has a classloader. This classloader 
  loads the classes from the plug-in as well as all the fragments. This leads 
  to situations where the host specifies a classpath entry such as &quot;$ws$/swt.jar&quot; 
  but does not in fact supply the swt.jar.</p>
<p>Under this new model, there is no reason for the host to specify a vacuous 
  classpath entry. Rather, it should remain silent about jars potentially supplied 
  by fragments and leave them to specify their own classpath.</p>
<p>The new fragment model sees fragments as first class entities which have classloaders 
  of their own (if needed) but yet delegate class/resource discovery to the classloader 
  of their host prior to consulting their own classpath. This is similar to the 
  standard Eclipse approach but leads to a situation where package visible code 
  in the host is not visible to code in the same package in fragments. This happens 
  because the two packages in question are actually managed by different classloaders 
  and so are in fact different packages.</p>
<p><b>Analysis:</b> The current Eclipse behaviour is somewhat anomalous in that 
  the runtime and the tooling have to take exceptional measures when computing 
  the classpath related to a set of fragments and their host plug-in. The new 
  approach simplifies this but does make it harder to generate the bundle manifests 
  corresponding to the plugin.xml and fragment.xmls using the old model. For example, 
  the current Equinox runtime relies on the SWT elements to include hand-crafted 
  manifest files with the characteristics outlined above.</p>
<p>The ability of fragments to see package visibility code in their host is an 
  asset for people writing tests and tools. For example, the Core Tools use this 
  to access internals of the runtime and resources plugins and interpret the behaviour 
  of these components. Similarly, white box test suites can be constructed using 
  package visible code and thus not forcing the exposure of internals as public 
  code.</p>
<p><b>Technical notes:</b> The Equinox team is investigating the fragment classloading 
  semantics to see if it is possible to merge the fragment and host classpaths. 
  They are also looking at enhancing the plug-in converter to analyze potential 
  cases and generate the appropriate classpath entries in the bundle and fragment 
  manifests.</p>
<table border=0 cellspacing=0 cellpadding=2 width="100%" >
  <tr> 
    <td align=LEFT valign=TOP colspan="2" bgcolor="#0080C0"><b><font color="#FFFFFF"> 
      Plug-in Development Notes</font></b></td>
  </tr>
</table>
<h3>Additional projects required</h3>
<p><b>Who is affected:</b> Plug-in developers setting up runtime workspaces or 
  maintaining build scripts.</p>
<p><b>Description: </b>Several new plug-ins have been added to support the new 
  runtime. When setting up a runtime workspace, developers will need to add projects 
  for these of these plug-ins to enable compilation. For more details, see the 
  <a href="adoption.html">Equinox Runtime Adoption Guide</a>.</p>
<h3>Build-related issues</h3>
<p><b>Who is affected:</b> Writers of bundles who want to make those bundles available 
  people using plug-in oriented tooling.</p>
<p><b>Description:</b> Current build structures (e.g., PDE, custom builds done 
  by product teams, ...) are based on plug-ins, fragments and features. While 
  the new runtime supports these components, it is bundle based. To support existing 
  build structures we (and other bundle developers) must take care to include 
  plugin.xml and fragment.xml files (as appropriate) for all bundles. This allows 
  the tooling and build mechanisms to correctly interpret the content of the bundle 
  and make it available.</p>
<p><b>Analysis:</b> By maintaining the plugin.xml content, tooling and build mechanisms 
  will continue to function. As these are updated to handle the new structures, 
  the need to maintain plugin.xml and fragment.xml files will diminish.</p>
<p>&nbsp;</p>
<p> </p>
</body>
</html>
