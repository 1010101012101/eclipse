<html>
<head>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<title>The Equinox Project - Migration Guide</title>
		<link rel="stylesheet" title="default" href="http://eclipse.org/default_style.css" type="text/css">
		<style>
			th,td { vertical-align:top; text-align=left}
			.issue { font-style:oblique; width:200px;}
			.box	{ background-color:#E0E0FF}
		</style>
	</head>
	<body>
		<table BORDER=0 CELLSPACING=5 CELLPADDING=2 WIDTH="100%" >
			<tr> 
				<td ALIGN=left width="60%">
					<p><font class=indextop> equinox</font><br>
        <font class=indexsub> porting guide</font> </p>
				</td>
				<td WIDTH="40%">&nbsp; </td>
			</tr>
		</table>

<blockquote> 
  <p><b>Summary</b> <br>
    This document details the API changes between the standard Eclipse runtime 
    (e.g., Eclipse 3.0 M5) to the OSGi-based runtime developed in the Equinox 
    project (e.g., Eclipse 3.0 M6). Information on migrating workspaces, code 
    and general workspace setup can be found in the <a href="adoption.html">Adoption 
    Guide</a> and information on how to use the new runtime is contained in the 
    <a href="howto.html">Users Guide</a>.<br>
    Last Modified: 1000 November 26, 2003</p>
</blockquote>
<table border=0 cellspacing=0 cellpadding=2 width="100%" >
  <tr> 
    <td align=LEFT valign=TOP colspan="2" bgcolor="#0080C0"><b><font color="#FFFFFF"> 
      API Changes</font></b></td>
  </tr>
</table>
<p> For each of the API changes listed below, there is a corresponding Bugzilla 
  bug report number. Readers are encouraged to comment on or track these bug reports 
  as a way of providing feedback into the Eclipse runtime design and implementation 
  process. All migration related bug reports have [migration] prepended to the 
  summary line. Users can query Bugzilla to get up to date information on new 
  issues as well as status on old/resolved issues.</p>
      
<h3>URL Stream Handler extensions (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=43400">43400</a>)</h3>
<p><b>Who is affected:</b> Plug-ins which contribute extensions to the <tt>org.eclipse.core.runtime.urlHandlers</tt> 
  extension point.</p>
<p><b>Description:</b> OSGi provides a URL Stream Handler service much like that 
  supported by Eclipse runtime. This allows people to register URL stream handlers 
  for different URL protocols (e.g., jndi: URLs). Because of various design issues 
  with the base Java URL handler mechanism, URLStreamHandlers registered with 
  the OSGi handler service must implement <tt>org.osgi.service.url.URLStreamHandlerService</tt>. 
  The OSGi framework provides a handy abstract superclass (<tt>org.osgi.service.url.AbstractURLStreamHandlerService</tt>) 
  that does the bulk of this work. </p>
<p>Unfortunately, legacy plug-ins which supply URL handler contributions (extensions 
  to the <tt>org.eclipse.core.runtime.urlHandlers</tt> extension point) implement 
  only the java.net.URLStreamHandler contract. Since all of the methods on URLStreamHandler 
  are protected, it is not possible for the runtime compatibility layer to simply 
  wrap such handlers to and give them the required behaviour. Rather, the implementation 
  of the handler must be updated either to implement <tt>org.osgi.service.url.URLStreamHandlerService</tt> 
  or to extend <tt>org.osgi.service.url.AbstractURLStreamHandlerService</tt>.</p>
<p><b>Analysis:</b> Very few plug-ins use this facility. A quick scan of major 
  Eclipse-based products (e.g., WSAD) failed to uncover any uses. Eclipse itself 
  uses this capability in the Help area (e.g., for help: and jndi: URLs). This 
  has usage has been updated as described above. </p>
<h3>Classload order (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=43401">43401</a>)</h3>
<p><b>Who is affected:</b> Plug-ins which supply packages provided which are also 
  supplied by other plug-ins.</p>
<p><b>Description:</b> In standard Eclipse, classloader search for classes using 
  the so-called PSP ordering. That is, a given classloader would first consult 
  its <b>p</b>arent classloader (in practice this is the Java boot classloader), 
  then its own classpath contents (i.e., <b>s</b>elf) and finally all of its <b>p</b>rerequisites 
  in declared order. OSGi offers an optimization over this model, the so-called 
  P-P|S (read P, P or S) ordering. In this approach a classloader will consult 
  its parent (again, effectively the Java boot classloader), then either a single 
  prerequisite known to contribute classes in the package being queried <b>OR</b> 
  its own classpath entries for the desired class.</p>
<p>The classloader determines whether to consult self or its prerequisites based 
  on its imported packages. This information is inferred from the plug-in content 
  in the case of legacy plug-ins and directly specified in the case of new plug-ins. 
  In either case, it is known a priori which classloaders will supply the classes 
  for which packages. This offers performance improvements as well as a solution 
  to the vexing problem of multiple prerequisites contributing the same classes.</p>
<p>Take for example the case of Xerces and Xalan. Both contain various classes 
  from org.xml packages. Under the PSP model, the Xerces plug-in would see its 
  copy of these classes while the Xalan plug-in would see their copy. Since these 
  plug-ins need to communicate, ClassCastExceptions occur. Under the P-P|S model, 
  only one of the two plug-ins contributes the duplicate classes and both plug-ins 
  see the same copies.</p>
<p><b>Analysis:</b> In a very limited number of cases the new behaviour will change 
  which classes are found. Note however that this may actually be beneficial (see 
  above).</p>
<h3>Support for multiple plug-in versions (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=43402">43402</a>)</h3>
<p><b>Who is affected:</b> System integrators/product developers expecting to 
  configure overlapping sets of plug-ins with different version numbers into one 
  Eclipse install.</p>
<p><b>Description: </b>Eclipse allows multiple versions of the same plug-in to 
  co-exist. Since OSGi resolves package imports/exports to one version it does 
  not support multiple plug-in versions. There are several proposals for adding 
  multiversion support to the OSGi framework. To date, all have deficiencies. 
  In the absence of a complete solution we are taking the simple approach and 
  allowing behaviour which is similar to that of original Eclipse. That is, the 
  resolver handles multiple versions and correctly binds dependencies. The runtime 
  then constructs the defined structures and executes them. This implementation 
  is in place though more work is needed to update the OSGi service mechanism 
  to filter properly.</p>
<h3>Package duplication (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=43403">43403</a>)</h3>
<p><b>Who is affected:</b> Plug-ins which <i>export</i> whole packages which are 
  also exported by other plug-ins.</p>
<p><b>Description: </b>Eclipse allows multiple copies of the same package to co-exist 
  (in different plug-ins). Since OSGi resolves package imports/exports to one 
  version it does not support multiple package copies. Note that this issue is 
  specific to package import and export. OSGi has been extended to include bundle 
  requires and provides mechanisms which will be familiar to Eclipse users. This 
  mechanism allows for package duplication (copies of the same package in multiple 
  places) as well as package splitting (the distribution of a package's classes 
  across several bundles). </p>
<p><b>Analysis:</b> Typical Eclipse usecases are not affected.</p>
<h3>Default package content cannot be shared (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=47517">47517</a>)</h3>
<p><b>Who is affected:</b> Plug-ins which expect to use types or resources in the 
  default package of another plug-in</p>
<p><b>Description:</b> In OSGi the only way for one bundle to access the code 
  or resources from another bundle is if the latter exports the package containing 
  the target code or resources. It is not possible to export the default package 
  as all bundles have the default package and the runtime would choose just one 
  under the normal package resolutions rules. In the Eclipse runtime this is not 
  a problem since code/resource sharing was available at the whole plug-in level 
  (i.e., everything in a plug-in could be made available to dependents).</p>
<p><b>Analysis:</b> The incidence of default package use is very low so the affects 
  are not widespread. For example, we have seen this in test suites where the 
  test bundles try to access files from the test target using getResource() and 
  the required file happens to be in the root of a jar on the classpath. </p>
<p>Plug-in developers can address this by moving such files but moving them to, 
  say icons/ in the jar (rather than the root) does not help because the package 
  &quot;icons&quot; would have to be exported and would surely conflict with some 
  other bundle doing the same. The best approach is to either put the files in 
  a real, unique, package or remove such files from the classpath and access them 
  via the Bundle.getFileEntry() API.</p>
<p><b>Technical notes:</b> This issue could be addressed in backwards compatible 
  way as part of the bundle as module work. If the dependent bundle imports the 
  prerequisite bundle (rather than specific packages), it should have access to 
  the prerequisite's entire list of provided packages. This list would include 
  the default package.</p>
<h3>PluginModel object casting (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=43404">43404</a>)</h3>
<p></p>
<p><b>Who is affected:</b> Plug-ins which cast objects of type IPlugin* to Plugin*Model.</p>
<p><b>Description:</b> The Eclipse API provides a series of interfaces (e.g., 
  <tt>IPluginDescriptor</tt>) and so-called &quot;model&quot; classes (e.g., <tt>PluginDescriptorModel</tt>) 
  related to plug-ins and the plug-in registry. In the implementation it happens 
  that the model classes implement the relevant interfaces. In the runtime we 
  are unable to maintain this relationship.</p>
<p><b>Analysis:</b> The relationship between the interfaces and the model classes 
  is not a specified part of the API. We have found however that PDE takes advantage 
  of this assumption. We do not expect there to be many (any) other uses of this 
  relationship and the PDE code is quite easily changed. </p>
<h3>Invalid assumptions regarding the form of URLs (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=43658">43406</a>)</h3>
<p><b>Who is affected:</b> Plug-ins which make assumptions regarding their installation 
  structure, location and the local file system layout.</p>
<p><b>Description:</b> Methods such as <tt>IPluginDescriptor.getInstallURL()</tt> 
  return URLs of a particular form. Despite this form not being specified, various 
  plug-ins make assumptions based on the current implementation. For example, 
  they may expect to get a file: URL and use <tt>URL.getFile()</tt> and use java.io.File 
  manipulation on the result. To date, this has been a workable but rather unsafe 
  approach. For example, if a plug-in is installed on a web server, it is possible 
  that an http: URL would be returned. The OSGi runtime opens more possibilities 
  for execution configurations (e.g., maintaining whole plugins in JARs rather 
  than exploded in directories). </p>
<p><b>Analysis:</b> The new runtime does not actually break current behaviour 
  but as described above, it exposes more cases where current assumptions are 
  invalid. Plug-in writers should ensure that the information to which they need 
  access is available via <tt>getResource()</tt>, use the relevant API for accessing 
  the contents of a bundle/plug-in.</p>
<h3>BootLoader API removed (<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=47516">47516</a>)</h3>
<p><b>Who is affected:</b> Plug-ins which use certain API from the class <tt>BootLoader</tt>.</p>
<p><b>Description:</b> Methods such as getRunnable(), startup(), shutdown() and 
  run() were removed from the BootLoader class supplied in the compatibility layer. 
</p>
<p><b>Analysis:</b> In general this API is used by very few people. It is intended 
  as the interface between the main() in startup.jar and the Eclipse runtime. 
  Having said that, in some cases this removal was too eager and the API should 
  be added back. This is under investigation.</p>

<table border=0 cellspacing=0 cellpadding=2 width="100%" >
  <tr> 
    <td align=LEFT valign=TOP colspan="2" bgcolor="#0080C0"><b><font color="#FFFFFF"> 
      Plug-in Development Notes</font></b></td>
  </tr>
</table>
<h3>Additional projects required</h3>
<p><b>Who is affected:</b> Plug-in developers setting up runtime workspaces or 
  maintaining build scripts.</p>
<p><b>Description: </b>Several new plug-ins have been added to support the new 
  runtime. When setting up a runtime workspace, developers will need to add projects 
  for these of these plug-ins to enable compilation. For more details, see the 
  <a href="adoption.html">Equinox Runtime Adoption Guide</a>.</p>
<h3>Build-related issues</h3>
<p><b>Who is affected:</b> Writers of bundles who want to make those bundles available 
  people using plug-in oriented tooling.</p>
<p><b>Description:</b> Current build structures (e.g., PDE, custom builds done 
  by product teams, ...) are based on plug-ins, fragments and features. While 
  the new runtime supports these components, it is bundle based. To support existing 
  build structures we (and other bundle developers) must take care to include 
  plugin.xml and fragment.xml files (as appropriate) for all bundles. This allows 
  the tooling and build mechanisms to correctly interpret the content of the bundle 
  and make it available.</p>
<p><b>Analysis:</b> By maintaining the plugin.xml content, tooling and build mechanisms 
  will continue to function. As these are updated to handle the new structures, 
  the need to maintain plugin.xml and fragment.xml files will diminish.</p>
<p>&nbsp;</p>
<p> </p>
</body>
</html>
